<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Notes | Student Companion</title>
  <style>
    /* ===== DARK BLUE COLOR SCHEME ===== */
    /* ===== DARK BLUE COLOR SCHEME ===== */
/* ===== DARK BLUE COLOR SCHEME ===== */
:root {
  --bg-primary: #0a0f2b;
  --bg-secondary: #131b3d;
  --bg-card: #1a2452;
  --bg-hover: #242f6b;
  --accent-primary: #3a7bd5;
  --accent-secondary: #00d2ff;
  --accent-danger: #ff4757;
  --text-primary: #ffffff;
  --text-secondary: #a0a8d6;
  --text-muted: #6b7299;
  --border-color: #2a3566;
  --shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
  --shadow-light: 0 4px 15px rgba(58, 123, 213, 0.3);
  --radius: 12px;
  --radius-sm: 8px;
}

/* ===== GLOBAL STYLES ===== */
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  height: 100%;
  font-family: 'Poppins', sans-serif;
}

body {
  background: linear-gradient(135deg, var(--bg-primary), var(--bg-secondary));
  color: var(--text-primary);
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  line-height: 1.6;
}

/* ===== HEADER ===== */
header {
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 5%;
  background: var(--bg-secondary);
  border-bottom: 2px solid var(--accent-primary);
  position: fixed;
  top: 0;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

header h1 {
  color: var(--accent-secondary);
  font-size: 1.5rem;
  font-weight: bold;
}

.toggle-sidebar {
  background: var(--accent-primary);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: 10px 14px;
  font-size: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: var(--shadow-light);
}

.toggle-sidebar:hover {
  background: #2d68c4;
  transform: scale(1.05);
}

.back-icon {
  width: 34px;
  height: 34px;
  fill: var(--accent-secondary);
  transition: all 0.3s ease;
}

.back-icon:hover {
  transform: scale(1.1);
  filter: drop-shadow(0 0 8px var(--accent-secondary));
}

/* ===== SIDEBAR ===== */
.sidebar {
  position: fixed;
  top: 0;
  left: -320px;
  width: 300px;
  height: 100vh;
  background: var(--bg-primary);
  border-right: 2px solid var(--border-color);
  display: flex;
  flex-direction: column;
  transition: left 0.3s ease;
  z-index: 1000;
  box-shadow: var(--shadow);
  overflow: hidden;
}

.sidebar.show {
  left: 0;
}

/* Sidebar Header */
.sidebar-header {
  padding: 80px 20px 20px 20px; /* Extra top padding for header */
  border-bottom: 1px solid var(--border-color);
  background: var(--bg-secondary);
  flex-shrink: 0;
}

/* Search Row */
.search-row {
  display: flex;
  gap: 10px;
  margin-bottom: 0;
}

#searchInput {
  flex: 1;
  background: var(--bg-card);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  padding: 12px 15px;
  color: var(--text-primary);
  font-size: 14px;
  transition: all 0.3s ease;
}

#searchInput:focus {
  outline: none;
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 2px rgba(58, 123, 213, 0.3);
}

#searchInput::placeholder {
  color: var(--text-muted);
}

#newNoteBtn {
  background: var(--accent-primary);
  color: white;
  border: none;
  border-radius: var(--radius-sm);
  padding: 12px 16px;
  cursor: pointer;
  font-weight: 600;
  transition: all 0.3s ease;
  white-space: nowrap;
  box-shadow: var(--shadow-light);
}

#newNoteBtn:hover {
  background: #2d68c4;
  transform: translateY(-2px);
}

/* Topic List Container */
.topic-list-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Compact Topic List */
.compact-list {
  list-style: none;
  padding: 20px;
  margin: 0;
  display: flex;
  flex-direction: column;
  gap: 10px;
  flex: 1;
  overflow-y: auto;
}

.compact-list::-webkit-scrollbar {
  width: 6px;
}

.compact-list::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

.compact-list::-webkit-scrollbar-thumb {
  background: var(--accent-primary);
  border-radius: 3px;
}

.compact-list::-webkit-scrollbar-thumb:hover {
  background: #2d68c4;
}

.topic-item {
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-sm);
  padding: 15px;
  cursor: pointer;
  transition: all 0.3s ease;
  border-left: 4px solid transparent;
}

.topic-item:hover {
  background: var(--bg-hover);
  transform: translateX(5px);
  border-left-color: var(--accent-primary);
}

.topic-item.active {
  background: var(--bg-hover);
  border-left: 4px solid var(--accent-primary);
}

.topic-content {
  flex: 1;
}

.topic-title {
  font-weight: bold;
  color: var(--text-primary);
  margin-bottom: 5px;
  font-size: 14px;
}

.topic-preview {
  color: var(--text-secondary);
  font-size: 0.9rem;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.topic-date {
  font-size: 0.8rem;
  color: var(--text-muted);
  margin-top: 5px;
}

/* ===== NOTE EDITOR ===== */
.note-editor {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 100px 40px 40px 40px; /* Extra top padding for header */
  background: var(--bg-card);
  margin-left: 0;
  transition: margin-left 0.3s ease;
  min-height: 100vh;
}

.sidebar.show ~ .note-editor {
  margin-left: 300px;
}

#noteTitle {
  color: var(--accent-secondary);
  font-size: 2rem;
  margin-bottom: 20px;
  padding: 10px;
  border: none;
  background: transparent;
  outline: none;
  border-bottom: 2px solid transparent;
  transition: all 0.3s ease;
  font-weight: bold;
}

#noteTitle:focus {
  border-bottom: 2px solid var(--accent-primary);
}

#noteTitle:empty:before {
  content: "Select or Create a Topic";
  color: var(--text-muted);
}

#noteContent {
  flex: 1;
  padding: 20px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--border-color);
  background: var(--bg-secondary);
  color: var(--text-primary);
  font-size: 1rem;
  line-height: 1.6;
  resize: none;
  outline: none;
  transition: all 0.3s ease;
  font-family: 'Poppins', sans-serif;
  min-height: 400px;
}

#noteContent:focus {
  border-color: var(--accent-primary);
  box-shadow: 0 0 0 2px rgba(58, 123, 213, 0.3);
}

#noteContent:disabled {
  background: var(--bg-primary);
  color: var(--text-muted);
  cursor: not-allowed;
}

#noteContent:disabled::placeholder {
  color: var(--text-muted);
}

.editor-actions {
  display: flex;
  gap: 15px;
  margin-top: 20px;
}

.editor-actions button {
  flex: 1;
  padding: 15px;
  border: none;
  border-radius: var(--radius-sm);
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  font-size: 1rem;
}

#saveNoteBtn {
  background: var(--accent-primary);
  color: white;
  box-shadow: var(--shadow-light);
}

#saveNoteBtn:hover {
  background: #2d68c4;
  transform: scale(1.05);
}

#deleteNoteBtn {
  background: var(--accent-danger);
  color: white;
  box-shadow: 0 4px 15px rgba(255, 71, 87, 0.3);
}

#deleteNoteBtn:hover {
  background: #ff3742;
  transform: scale(1.05);
}

/* ===== OVERLAY ===== */
.sidebar-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 999;
  display: none;
}

.sidebar.show ~ .sidebar-overlay {
  display: block;
}

/* ===== FLOATING AI ===== */
.floating-ai {
  position: fixed;
  bottom: 30px;
  right: 30px;
  background: var(--accent-primary);
  padding: 15px 25px;
  border-radius: 30px;
  color: white;
  font-weight: 600;
  font-size: 16px;
  text-decoration: none;
  box-shadow: var(--shadow-light);
  transition: 0.3s ease;
  z-index: 900;
  display: flex;
  align-items: center;
  gap: 8px;
}

.floating-ai:hover {
  transform: scale(1.07);
  box-shadow: 0 0 20px rgba(0, 210, 255, 0.7);
  background: #2d68c4;
}

/* ===== CUSTOM SCROLLBAR ===== */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: var(--bg-secondary);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: var(--accent-primary);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #2d68c4;
}

/* ===== RESPONSIVE DESIGN ===== */
@media (max-width: 768px) {
  .sidebar {
    width: 280px;
    left: -280px;
  }
  
  .sidebar.show ~ .note-editor {
    margin-left: 0;
  }
  
  .note-editor {
    padding: 80px 20px 20px 20px;
  }
  
  #noteTitle {
    font-size: 1.6rem;
  }
  
  .sidebar-header {
    padding: 70px 15px 15px 15px;
  }
  
  .compact-list {
    padding: 15px;
  }
  
  .floating-ai {
    bottom: 20px;
    right: 20px;
    padding: 12px 20px;
    font-size: 14px;
  }
}

@media (max-width: 480px) {
  header {
    padding: 12px 5%;
  }
  
  header h1 {
    font-size: 1.3rem;
  }
  
  .toggle-sidebar {
    padding: 8px 12px;
    font-size: 18px;
  }
  
  .note-editor {
    padding: 70px 15px 15px 15px;
  }
  
  #noteTitle {
    font-size: 1.4rem;
  }
  
  .editor-actions {
    flex-direction: column;
    gap: 10px;
  }
  
  .search-row {
    flex-direction: column;
  }
}
  </style>
</head>
<body>
  <header>
    <button id="toggleSidebarBtn" class="toggle-sidebar" aria-label="Toggle topics">‚ò∞</button>
    <h1>NOTES</h1>
    <nav>
      <ul>
        <li>
          <a href="homepage.html" aria-label="Back to homepage">
            <svg class="back-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
              <path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/>
            </svg>
          </a>
        </li>
      </ul>
    </nav>
  </header>
<!-- Toggle Button -->
<button class="toggle-btn">üìù Notes</button>

<!-- Replace your sidebar section with this: -->
<main class="sidebar">
  <aside class="sidebar-header">
    <div class="search-row">
      <input id="searchInput" type="text" placeholder="Search topic..." autocomplete="on" />
      <button id="newNoteBtn" title="New note">+ New</button>
    </div>
  </aside>

  <!-- Add topic list container -->
  <div class="topic-list-container">
    <ul id="topicList" class="compact-list">
      <!-- Topics will be populated by JavaScript -->
    </ul>
  </div>
</main>

<!-- Overlay for mobile -->
<div class="sidebar-overlay"></div>

<!-- Editor -->
<section class="note-editor">
  <h2 id="noteTitle" contenteditable="true" spellcheck="false">Select or Create a Topic</h2>
  <textarea id="noteContent" placeholder="Start writing your note..." disabled></textarea>

  <div class="editor-actions">
    <button id="saveNoteBtn">üíæ Save</button>
    <button id="deleteNoteBtn">üóë Delete</button>
  </div>
</section>
  </main>

  <!-- Expanded search panel / overlay -->
  <div id="searchOverlay">
    <div id="searchPanel" class="search-panel" role="dialog" aria-modal="true">
      <div class="search-panel-top">
        <input id="expandedSearchInput" type="text" placeholder="Search topics, or type to create..." autocomplete="on" />
        
      </div>

      <div id="searchResults" class="search-results">
        <!-- results will be injected here as list items (title + snippet) -->
      </div>
    </div>
  </div>

  <!-- Floating AI Button -->
  

    <script>
      /* 
  notes.js
  - Expanded search panel that contains New + results
  - Live search across title and content
  - Click outside closes panel
  - If localStorage.authToken exists, the client will attempt to use backend endpoints.
    Otherwise falls back to localStorage-only mode.
*/

/* CONFIG: change base API path if your server uses a different prefix */
const API_BASE = "/api/notes"; // expected endpoints: GET /api/notes, POST /api/notes, PUT /api/notes/:id, DELETE /api/notes/:id

// DOM
const searchInput = document.getElementById("searchInput");
const newNoteBtn = document.getElementById("newNoteBtn");
const topicList = document.getElementById("topicList");
const noteTitle = document.getElementById("noteTitle");
const noteContent = document.getElementById("noteContent");
const saveNoteBtn = document.getElementById("saveNoteBtn");
const deleteNoteBtn = document.getElementById("deleteNoteBtn");
// sidebar toggle elements
const toggleSidebar = document.getElementById("toggleSidebarBtn");
const sidebar = document.querySelector(".sidebar");
const noteEditorSection = document.querySelector(".note-editor");

// overlay panel elements
const searchOverlay = document.getElementById("searchOverlay");
const expandedSearchInput = document.getElementById("expandedSearchInput");
const panelNewBtn = document.getElementById("panelNewBtn");
const searchResults = document.getElementById("searchResults");

let notes = [];           // in-memory notes list
let activeNote = null;    // currently opened note object
let useBackend = !!localStorage.getItem("authToken"); // if true attempt server sync

// ================= USER MANAGEMENT ================= //
function getCurrentUser() { return localStorage.getItem("currentUser"); }

function signup(username, password) {
  if (!username || !password) return alert("Please fill all fields!");
  let users = JSON.parse(localStorage.getItem("users")) || {};
  if (users[username]) return alert("User already exists!");
  users[username] = { password, notes: [], timetable: [], gpa: [], profile: {}, notifications: [] };
  localStorage.setItem("users", JSON.stringify(users));
  alert("Account created! Please login.");
  window.location.href = "index.html";
}

function login(username, password) {
  let users = JSON.parse(localStorage.getItem("users")) || {};
  if (users[username] && users[username].password === password) {
    localStorage.setItem("currentUser", username);
    window.location.href = "homepage.html";
  } else alert("Invalid username or password.");
}

function logout() {
  localStorage.removeItem("currentUser");
  window.location.href = "index.html";
}


// --- HELPERS: backend vs local operations ---
// fetch wrapper that attaches auth token if present
async function apiFetch(url, opts = {}) {
  const token = localStorage.getItem("authToken");
  const headers = opts.headers || {};
  if (token) headers["Authorization"] = `Bearer ${token}`;
  opts.headers = {...headers, "Content-Type":"application/json"};
  const resp = await fetch(url, opts);
  if (!resp.ok) {
    const text = await resp.text();
    throw new Error(`API error ${resp.status}: ${text}`);
  }
  return resp.json();
}

// load notes (tries backend first if token present)
async function loadNotes() {
  if (useBackend) {
    try {
      const data = await apiFetch(API_BASE, { method: "GET" }); // expects array
      notes = Array.isArray(data) ? data : [];
      renderCompactList();
      return;
    } catch (err) {
      console.warn("Backend notes fetch failed, falling back to localStorage:", err.message);
      useBackend = false;
    }
  }
  // fallback to localStorage
  // If a user is logged in we prefer user-scoped notes stored under `users[username].notes`.
  const user = getCurrentUser();
  if (user) {
    const users = JSON.parse(localStorage.getItem('users') || '{}');
    notes = Array.isArray(users[user]?.notes) ? users[user].notes.slice() : [];
  } else {
    notes = JSON.parse(localStorage.getItem("notes") || "[]");
  }
  renderCompactList();
}

// save a note: if backend is used call PUT/POST, otherwise update localStorage
async function persistNote(note) {
  if (!note) return;
  if (useBackend) {
    try {
      if (!note._persisted) {
        // create
        const created = await apiFetch(API_BASE, { method: "POST", body: JSON.stringify(note) });
        // expect created note with id
        Object.assign(note, created);
        note._persisted = true;
      } else {
        await apiFetch(`${API_BASE}/${note.id}`, { method: "PUT", body: JSON.stringify(note) });
      }
      // reload list from server for canonical state
      await loadNotes();
      return;
    } catch (err) {
      console.error("Persist to backend failed:", err.message);
      // fallback: mark as local and continue
    }
  }

  // local storage flow
  const user = getCurrentUser();
  if (user) {
    const users = JSON.parse(localStorage.getItem('users') || '{}');
    if (!users[user]) users[user] = { password: '', notes: [], timetable: [], gpa: [], profile: {}, notifications: [] };
    if (!Array.isArray(users[user].notes)) users[user].notes = [];
    const store = users[user].notes;
    const idx = store.findIndex(n => n.id === note.id);
    if (idx >= 0) store[idx] = note;
    else store.unshift(note);
    users[user].notes = store;
    localStorage.setItem('users', JSON.stringify(users));
    notes = store.slice();
  } else {
    const store = JSON.parse(localStorage.getItem("notes") || "[]");
    const idx = store.findIndex(n => n.id === note.id);
    if (idx >= 0) store[idx] = note;
    else store.unshift(note);
    localStorage.setItem("notes", JSON.stringify(store));
    notes = store;
  }
  renderCompactList();
}

// delete note
async function removeNote(noteId) {
  if (!noteId) return;
  if (useBackend) {
    try {
      await apiFetch(`${API_BASE}/${noteId}`, { method: "DELETE" });
      await loadNotes();
      return;
    } catch (err) {
      console.warn("Backend delete failed, falling back to local remove:", err.message);
      useBackend = false;
    }
  }
  const user = getCurrentUser();
  if (user) {
    const users = JSON.parse(localStorage.getItem('users') || '{}');
    if (!users[user] || !Array.isArray(users[user].notes)) return;
    users[user].notes = (users[user].notes || []).filter(n => n.id !== noteId);
    localStorage.setItem('users', JSON.stringify(users));
    notes = users[user].notes.slice();
  } else {
    notes = notes.filter(n => n.id !== noteId);
    localStorage.setItem("notes", JSON.stringify(notes));
  }
  renderCompactList();
}

/* UI RENDERING */

// compact sidebar list
function renderCompactList() {
  topicList.innerHTML = "";
  if (!notes || notes.length === 0) {
    topicList.innerHTML = `<li class="no-results">No topics yet</li>`;
    return;
  }
  notes.forEach(n => {
    const li = document.createElement("li");
    li.dataset.id = n.id;
    li.className = 'topic-row';

    const title = document.createElement('span');
    title.className = 'topic-title';
    title.textContent = n.title || 'Untitled';
    if (activeNote && activeNote.id === n.id) title.classList.add('active');
    title.addEventListener('click', () => { loadNoteById(n.id); collapseSearchPanel(); });

    const actions = document.createElement('div');
    actions.className = 'topic-actions';
  // compact actions: (edit/delete are appended later)
    li.appendChild(title);
    li.appendChild(actions);
    topicList.appendChild(li);
  });
}

// render results in expanded panel (title + snippet)
function renderSearchResults(list) {
  searchResults.innerHTML = "";
  if (!list.length) {
    searchResults.innerHTML = `<div class="no-results">No matches</div>`;
    return;
  }
  list.forEach(n => {
    const item = document.createElement('div');
    item.className = 'result-item';

    const left = document.createElement('div');
    left.className = 'result-left';
    const t = document.createElement('div');
    t.className = 'result-title';
    t.textContent = n.title || 'Untitled';
    const s = document.createElement('div');
    s.className = 'result-snippet';
    const snippet = (n.content || '').replace(/\s+/g, ' ').trim().slice(0,120);
    s.textContent = snippet || '‚Äî no content ‚Äî';
    left.appendChild(t);
    left.appendChild(s);

    const right = document.createElement('div');
    right.className = 'result-actions';
    const openBtn = document.createElement('button');
    openBtn.type = 'button';
    openBtn.className = 'open-note-btn';
    openBtn.textContent = 'Open';
    openBtn.addEventListener('click', () => { loadNoteById(n.id); collapseSearchPanel(); });

    right.appendChild(openBtn);

    item.appendChild(left);
    item.appendChild(right);
    searchResults.appendChild(item);
  });
}

/* SEARCH logic: searches title AND content (case-insensitive) */
function searchNotes(term) {
  const q = (term || "").trim().toLowerCase();
  if (!q) {
    renderSearchResults(notes);
    return notes;
  }
  const results = notes.filter(n => {
    const inTitle = (n.title || "").toLowerCase().includes(q);
    const inContent = (n.content || "").toLowerCase().includes(q);
    return inTitle || inContent;
  });
  renderSearchResults(results);
  return results;
}

/* NOTE operations */

function createLocalNote() {
  const newNote = {
    id: String(Date.now()), // use string id to avoid collisions
    title: "Change Topic Here -->",
    content: "",
    userId: getCurrentUser() || null // backend can attach user; local copy stores owner when available
  };
  // for backend, we mark _persisted false; after server create we'll copy server ID
  newNote._persisted = false;
  notes.unshift(newNote); // insert at top
  // if not using backend persist immediately
  if (!useBackend) {
    localStorage.setItem("notes", JSON.stringify(notes));
  }
  renderCompactList();
  loadNote(newNote);
  return newNote;
}

async function createNoteAndPersist() {
  const n = createLocalNote();
  try {
    await persistNote(n);
  } catch (err) {
    console.warn("Could not persist new note:", err.message);
  }
}

function loadNote(noteObj) {
  activeNote = noteObj;
  noteTitle.textContent = noteObj.title || "Untitled";
  noteContent.value = noteObj.content || "";
  noteContent.disabled = false;
  renderCompactList();
  // Store the full note in localStorage so AI page can pick it up when opened
  try {
    const prompt = `${noteObj.title || ''}\n\n${noteObj.content || ''}`.trim();
    localStorage.setItem('aiPrompt', prompt);
    if (noteObj.id) localStorage.setItem('aiNoteId', String(noteObj.id));
  } catch (e) { /* ignore storage errors */ }
}

function loadNoteById(id) {
  const note = notes.find(n => String(n.id) === String(id));
  if (!note) return;
  loadNote(note);
}



/* EVENT HANDLERS */

// small search input triggers the panel (to provide bigger placeholder)
searchInput.addEventListener("focus", () => {
  // set expanded input initial value from compact one
  expandedSearchInput.value = searchInput.value;
  expandSearchPanel();
});

expandedSearchInput.addEventListener("input", (e) => {
  const v = e.target.value;
  searchInput.value = v; // keep compact input synced
  searchNotes(v);
});

// panel New & compact New

newNoteBtn.addEventListener("click", async () => {
  await createNoteAndPersist();
});


// global save / delete buttons
saveNoteBtn && saveNoteBtn.addEventListener("click", async () => {
  if (!activeNote) return alert("Select or create a note first.");
  // take title from contenteditable and content from textarea
  activeNote.title = noteTitle.textContent.trim() || "Untitled";
  activeNote.content = noteContent.value;
  await persistNote(activeNote);
  // reflect changes in UI
  renderCompactList();
  alert("Note saved.");
});

deleteNoteBtn && deleteNoteBtn.addEventListener("click", async () => {
  if (!activeNote) return alert("Select a note to delete.");
  const ok = confirm("Delete this note?");
  if (!ok) return;
  const id = activeNote.id;
  activeNote = null;
  await removeNote(id);
  // clear editor
  noteTitle.textContent = "Select or Create a Topic";
  noteContent.value = "";
  noteContent.disabled = true;
  alert("Note deleted.");
});

// auto-save when typing (throttle to avoid too many writes)
let autoSaveTimer = null;
noteTitle.addEventListener("input", () => {
  if (!activeNote) return;
  // update in memory immediately
  activeNote.title = noteTitle.textContent;
  if (autoSaveTimer) clearTimeout(autoSaveTimer);
  autoSaveTimer = setTimeout(() => persistNote(activeNote), 700);
});
noteContent.addEventListener("input", () => {
  if (!activeNote) return;
  activeNote.content = noteContent.value;
  if (autoSaveTimer) clearTimeout(autoSaveTimer);
  autoSaveTimer = setTimeout(() => persistNote(activeNote), 700);
});

// compact search box typing should filter the compact list in-place
searchInput.addEventListener("input", (e) => {
  const term = e.target.value;
  // filter compact list (not the overlay) for quick browsing
  const filtered = (notes || []).filter(n => {
    const q = term.toLowerCase();
    return (n.title || "").toLowerCase().includes(q) || (n.content || "").toLowerCase().includes(q);
  });
  // render filtered compact items
  topicList.innerHTML = "";
  if (!filtered.length) { topicList.innerHTML = `<li class="no-results">No topics</li>`; return; }
  filtered.forEach(n => {
    const li = document.createElement("li");
    li.textContent = n.title || "Untitled";
    li.dataset.id = n.id;
    li.addEventListener("click", () => loadNoteById(n.id));
    topicList.appendChild(li);
  });
});

/* INITIALIZE */
(async function init(){
  // load notes (server if token present, else local)
  await loadNotes();
  // if we have notes, preselect the first
  if (notes && notes.length) loadNote(notes[0]);
})();

// --- Sidebar Toggle behavior (works on desktop and mobile)
if (toggleSidebar && sidebar && noteEditorSection) {
  // click toggles collapsed state on desktop, and toggles off-canvas on mobile
  toggleSidebar.addEventListener("click", (e) => {
    e.stopPropagation();
    if (window.innerWidth <= 700) {
      // mobile: toggle off-canvas visibility
      sidebar.classList.toggle("show");
    } else {
      // desktop: collapse to zero width to give editor more space
      sidebar.classList.toggle("collapsed");
      noteEditorSection.classList.toggle("fullwidth", sidebar.classList.contains("collapsed"));
    }
  });

  // clicking outside on mobile hides the off-canvas sidebar
  document.addEventListener("click", (e) => {
    if (window.innerWidth <= 700 && sidebar.classList.contains("show")) {
      if (!sidebar.contains(e.target) && e.target !== toggleSidebar) {
        sidebar.classList.remove("show");
      }
    }
  });

  // on resize ensure state is reasonable
  window.addEventListener("resize", () => {
    if (window.innerWidth > 700) {
      // remove mobile 'show' if present; keep collapsed state across resizes
      sidebar.classList.remove("show");
    }
  });
}
    </script>
</body>
</html>