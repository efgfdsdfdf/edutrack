<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Student Companion AI</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
    <style>
        /* Reset & Base */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'SF Mono', 'Fira Code', 'Roboto Mono', monospace, sans-serif;
    background: #0a0a14;
    color: #e0e0ff;
    min-height: 100vh;
    overflow-x: hidden;
    background-image: 
        radial-gradient(circle at 10% 20%, rgba(138, 43, 226, 0.08) 0%, transparent 25%),
        radial-gradient(circle at 90% 80%, rgba(0, 255, 255, 0.06) 0%, transparent 25%),
        linear-gradient(135deg, #0a0a14 0%, #121225 100%);
}

/* Grid Background Effect */
body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        linear-gradient(rgba(138, 43, 226, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(138, 43, 226, 0.05) 1px, transparent 1px);
    background-size: 50px 50px;
    z-index: -1;
    pointer-events: none;
}

/* Layout */
.app-container {
    display: flex;
    height: 100vh;
}

/* Sidebar */
.sidebar {
    width: 280px;
    background: rgba(18, 18, 37, 0.95);
    border-right: 1px solid #8a2be2;
    display: flex;
    flex-direction: column;
    position: fixed;
    left: -280px;
    top: 0;
    bottom: 0;
    transition: left 0.3s ease;
    z-index: 1000;
    box-shadow: 0 0 30px rgba(138, 43, 226, 0.15);
    backdrop-filter: blur(10px);
}

.sidebar.active {
    left: 0;
    box-shadow: 4px 0 25px rgba(138, 43, 226, 0.2);
}

.sidebar-header {
    padding: 20px;
    border-bottom: 1px solid #00ffff;
    background: rgba(10, 10, 20, 0.8);
}

.nav-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px 20px;
    color: #b19cd9;
    text-decoration: none;
    transition: all 0.2s;
    border-radius: 8px;
    margin: 4px 0;
    border: 1px solid transparent;
    position: relative;
    overflow: hidden;
}

.nav-item::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    width: 3px;
    background: linear-gradient(to bottom, #8a2be2, #00ffff);
    transform: translateX(-100%);
    transition: transform 0.3s;
}

.nav-item:hover {
    background: rgba(138, 43, 226, 0.1);
    color: #d4b3ff;
    border-color: #8a2be2;
    box-shadow: 0 0 15px rgba(138, 43, 226, 0.2);
}

.nav-item:hover::before {
    transform: translateX(0);
}

.new-chat-btn {
    width: 100%;
    margin-top: 20px;
    padding: 14px;
    background: linear-gradient(135deg, #8a2be2, #9400d3);
    color: white;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.4);
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
}

.new-chat-btn::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -60%;
    width: 50px;
    height: 200%;
    background: rgba(255, 255, 255, 0.1);
    transform: rotate(30deg);
    transition: all 0.6s;
}

.new-chat-btn:hover {
    background: linear-gradient(135deg, #9400d3, #8a2be2);
    box-shadow: 0 0 30px rgba(138, 43, 226, 0.6);
    transform: translateY(-2px);
}

.new-chat-btn:hover::after {
    left: 120%;
}

.chat-history {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
}

.chat-item {
    padding: 12px;
    margin: 8px 0;
    background: rgba(25, 25, 45, 0.8);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    border: 1px solid rgba(138, 43, 226, 0.3);
    overflow: hidden;
}

.chat-item:hover {
    background: rgba(138, 43, 226, 0.1);
    border-color: #8a2be2;
    box-shadow: 0 0 15px rgba(138, 43, 226, 0.2);
    transform: translateX(5px);
}

/* DELETE BUTTON ALWAYS VISIBLE ON MOBILE */
.chat-item .delete-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(255, 0, 100, 0.2);
    border: 1px solid #ff0064;
    color: #ff66a3;
    width: 28px;
    height: 28px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    opacity: 1; /* Always visible on mobile */
    transition: all 0.2s;
    font-size: 0.9rem;
    z-index: 2;
}

.chat-item .delete-btn:hover {
    background: rgba(255, 0, 100, 0.4);
    transform: scale(1.1);
    box-shadow: 0 0 10px rgba(255, 0, 100, 0.3);
}

/* On desktop, hide by default, show on hover */
@media (min-width: 769px) {
    .chat-item .delete-btn {
        opacity: 0;
    }
    
    .chat-item:hover .delete-btn {
        opacity: 1;
    }
}

/* Mobile overlay */
.sidebar-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.85);
    z-index: 999;
    animation: fadeIn 0.3s ease;
    backdrop-filter: blur(3px);
}

.sidebar-overlay.active {
    display: block;
}

/* Main Chat Area */
.main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100vh;
    transition: all 0.3s ease;
    background: #0a0a14;
    position: relative;
}

.chat-header {
    padding: 16px 24px;
    background: rgba(18, 18, 37, 0.95);
    border-bottom: 1px solid #00ffff;
    display: flex;
    align-items: center;
    gap: 16px;
    position: sticky;
    top: 0;
    z-index: 100;
    backdrop-filter: blur(10px);
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
}

.menu-toggle {
    background: none;
    border: 1px solid #8a2be2;
    color: #8a2be2;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 8px;
    border-radius: 8px;
    transition: all 0.2s;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
}

.menu-toggle::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, transparent 30%, rgba(138, 43, 226, 0.1) 50%, transparent 70%);
    transform: translateX(-100%);
    transition: transform 0.6s;
}

.menu-toggle:hover {
    background: rgba(138, 43, 226, 0.1);
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.3);
    color: #d4b3ff;
}

.menu-toggle:hover::before {
    transform: translateX(100%);
}

.chat-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #00ffff;
    text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    background: linear-gradient(90deg, #8a2be2, #00ffff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

/* Chat Messages */
.chat-messages {
    flex: 1;
    padding: 24px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 20px;
    scroll-behavior: smooth;
}

/* ===== UPDATED: AI MESSAGE STYLING (NO BOX) ===== */
.ai-message {
    align-self: flex-start;
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    padding: 0 !important;
    max-width: 100% !important;
    margin: 10px 0 20px 0;
    position: relative;
    width: 100%;
}

/* User messages keep their styling */
.user-message {
    align-self: flex-end;
    background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(148, 0, 211, 0.3));
    color: #e0d6ff;
    position: relative;
    border-color: #8a2be2;
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.2);
    border-left: 4px solid #8a2be2;
    border-radius: 20px;
    padding: 16px 20px;
    max-width: 85%;
    margin: 10px 0;
}

/* AI content as plain text */
.ai-content {
    font-size: 1rem;
    color: #e0e0ff;
    line-height: 1.6;
    padding: 0;
    background: transparent;
    border: none;
    box-shadow: none;
    width: 100%;
}

/* Headers in AI content */
.ai-content h1 { 
    font-size: 1.8rem; 
    margin: 25px 0 15px; 
    color: #8a2be2;
    padding-bottom: 8px;
    border-bottom: 2px solid rgba(138, 43, 226, 0.3);
}
.ai-content h2 { 
    font-size: 1.5rem; 
    margin: 22px 0 12px; 
    color: #d4b3ff;
}
.ai-content h3 { 
    font-size: 1.3rem; 
    margin: 20px 0 10px; 
    color: #a3d9ff;
}
.ai-content p { 
    margin-bottom: 18px; 
    color: #d0d0ff;
}
.ai-content ul, .ai-content ol { 
    margin: 15px 0 15px 25px; 
}
.ai-content li { 
    margin-bottom: 8px; 
    color: #c0c0ff;
}

/* ===== UPDATED: CODE BLOCK WITH STICKY COPY BUTTON ===== */
.code-block-wrapper {
    position: relative;
    margin: 25px 0;
    border-radius: 12px;
    overflow: hidden;
    border: 2px solid #8a2be2;
    background: #121225;
    box-shadow: 0 0 25px rgba(138, 43, 226, 0.25);
    max-height: 500px;
    display: flex;
    flex-direction: column;
}

/* Sticky header that stays at top during scroll */
.code-header {
    position: sticky;
    top: 0;
    z-index: 100;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(138, 43, 226, 0.25);
    padding: 12px 16px;
    border-bottom: 1px solid #00ffff;
    min-height: 48px;
    backdrop-filter: blur(10px);
}

.code-language {
    font-size: 0.9rem;
    color: #00ffff;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
    font-family: 'Fira Code', monospace;
}

.code-copy-btn {
    background: linear-gradient(135deg, #8a2be2, #00ffff);
    color: white;
    border: 1px solid #8a2be2;
    border-radius: 8px;
    padding: 8px 16px;
    font-size: 0.85rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.2s;
    font-family: 'Fira Code', monospace;
    font-weight: 600;
    z-index: 101;
}

.code-copy-btn:hover {
    background: linear-gradient(135deg, #00ffff, #8a2be2);
    transform: translateY(-2px);
    box-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
}

.code-copy-btn.copied {
    background: #00ffff;
    color: #121225;
}

/* Download All Files Button */
.download-all-btn {
    background: linear-gradient(135deg, #00b09b, #96c93d);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 10px 18px;
    font-size: 0.85rem;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.2s;
    font-weight: 600;
    box-shadow: 0 0 15px rgba(0, 176, 155, 0.3);
}

.download-all-btn:hover {
    background: linear-gradient(135deg, #96c93d, #00b09b);
    transform: translateY(-2px);
    box-shadow: 0 0 20px rgba(0, 176, 155, 0.5);
}

.download-all-btn:active {
    transform: translateY(0);
}

/* Scrollable code content */
.code-block {
    background: #121225;
    padding: 20px;
    overflow-x: auto;
    margin: 0;
    flex: 1;
    overflow-y: auto;
}

pre {
    margin: 0;
    font-family: 'Fira Code', 'Monaco', 'Menlo', monospace;
    font-size: 0.95rem;
    line-height: 1.5;
    tab-size: 4;
    color: #e0d6ff;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/* Fix for HTML code display */
.code-block-wrapper.html pre code {
    color: #e0d6ff;
}

.code-block-wrapper.html pre code .hljs-tag,
.code-block-wrapper.html pre code .hljs-name {
    color: #ff6b6b;
}

.code-block-wrapper.html pre code .hljs-attr {
    color: #ffcc00;
}

.code-block-wrapper.html pre code .hljs-string {
    color: #a5ff90;
}

/* Remove retry button from AI messages */
.ai-message .retry-btn-outside {
    display: none !important;
}

/* RETRY BUTTON ONLY FOR USER MESSAGES */
.user-message .retry-btn-outside {
    position: absolute;
    bottom: -12px;
    left: -12px;
    background: linear-gradient(135deg, #ff0064, #ff4081);
    color: white;
    border: none;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 10;
    box-shadow: 0 4px 12px rgba(255, 0, 100, 0.4);
    font-size: 1rem;
    opacity: 1;
    transition: all 0.3s;
    border: 1px solid #ff66a3;
}

.retry-btn-outside:hover {
    background: linear-gradient(135deg, #ff4081, #ff0064);
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(255, 0, 100, 0.6);
}

/* USER MESSAGE ACTIONS */
.user-message .message-actions {
    position: absolute;
    bottom: -12px;
    right: 12px;
    background: rgba(138, 43, 226, 0.9);
    border: 1px solid #8a2be2;
    border-radius: 8px;
    padding: 4px;
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 10;
    backdrop-filter: blur(5px);
}

.ai-message .message-actions {
    position: absolute;
    top: -12px;
    right: 12px;
    background: rgba(0, 255, 255, 0.9);
    border: 1px solid #00ffff;
    border-radius: 8px;
    padding: 4px;
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 10;
    backdrop-filter: blur(5px);
}

.message:hover .message-actions {
    opacity: 1;
}

/* Always show actions for editing */
.message.editing .message-actions {
    opacity: 1;
}

.message-action-btn {
    width: 28px;
    height: 28px;
    border-radius: 6px;
    border: none;
    background: rgba(255, 255, 255, 0.15);
    color: #e0e0ff;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    backdrop-filter: blur(5px);
}

.message-action-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    color: white;
    transform: scale(1.1);
}

/* Message Editing - KEEP SAME FORM */
.message-editing {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: inherit; /* Keep same background */
    border-radius: 20px;
    padding: 16px 20px;
    display: none;
    flex-direction: column;
    gap: 12px;
    z-index: 20;
}

.message.editing .message-editing {
    display: flex;
}

.edit-textarea {
    flex: 1;
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #8a2be2;
    border-radius: 12px;
    padding: 12px;
    color: #e0d6ff;
    font-family: 'Fira Code', monospace;
    font-size: 1rem;
    resize: none;
    outline: none;
    min-height: 60px;
    box-shadow: 0 0 15px rgba(138, 43, 226, 0.3);
    transition: all 0.3s;
}

.edit-textarea:focus {
    border-color: #00ffff;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
}

.edit-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
}

.edit-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s;
    font-family: 'SF Mono', monospace;
}

.edit-save {
    background: linear-gradient(135deg, #8a2be2, #00ffff);
    color: white;
    border: 1px solid #8a2be2;
}

.edit-save:hover {
    background: linear-gradient(135deg, #00ffff, #8a2be2);
    box-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
    transform: translateY(-2px);
}

.edit-cancel {
    background: rgba(255, 255, 255, 0.1);
    color: #00ffff;
    border: 1px solid #00ffff;
}

.edit-cancel:hover {
    background: rgba(0, 255, 255, 0.2);
}

/* Inline code styling */
.ai-content code:not(pre code) {
    background: rgba(138, 43, 226, 0.15);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'Fira Code', monospace;
    color: #00ffff;
    border: 1px solid rgba(0, 255, 255, 0.3);
}

/* File Separation Dialog */
.file-dialog {
    background: rgba(25, 25, 45, 0.9);
    border: 1px solid #8a2be2;
    border-radius: 12px;
    padding: 16px;
    margin: 12px 0;
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.2);
    backdrop-filter: blur(5px);
}

.file-dialog-title {
    font-size: 1rem;
    margin-bottom: 12px;
    color: #00ffff;
    display: flex;
    align-items: center;
    gap: 8px;
    text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
}

.file-dialog-options {
    display: flex;
    gap: 12px;
    margin: 12px 0;
}

.file-option-btn {
    flex: 1;
    padding: 10px;
    border: 1px solid rgba(138, 43, 226, 0.5);
    background: rgba(138, 43, 226, 0.1);
    color: #d4b3ff;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
}

.file-option-btn:hover {
    background: rgba(138, 43, 226, 0.2);
    border-color: #8a2be2;
    color: #e0d6ff;
    box-shadow: 0 0 15px rgba(138, 43, 226, 0.3);
}

.file-option-btn.selected {
    background: rgba(138, 43, 226, 0.3);
    border-color: #8a2be2;
    color: #ffffff;
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.4);
}

/* Typing Animation */
.typing-cursor {
    display: inline-block;
    width: 2px;
    height: 1.2em;
    background: #00ffff;
    margin-left: 2px;
    vertical-align: middle;
    animation: blink 1s infinite;
    box-shadow: 0 0 8px #00ffff;
}

@keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
}

/* Input Area */
.input-container {
    padding: 16px 24px;
    background: rgba(18, 18, 37, 0.95);
    border-top: 1px solid #8a2be2;
    backdrop-filter: blur(10px);
    box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.3);
}

.input-wrapper {
    display: flex;
    gap: 12px;
    align-items: flex-end;
}

textarea {
    flex: 1;
    padding: 16px 20px;
    border: 1px solid rgba(138, 43, 226, 0.5);
    background: rgba(25, 25, 45, 0.8);
    color: #e0d6ff;
    border-radius: 20px;
    resize: none;
    font-family: 'Fira Code', monospace;
    font-size: 1rem;
    min-height: 56px;
    max-height: 200px;
    outline: none;
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.15);
    transition: all 0.3s;
}

textarea:focus {
    border-color: #00ffff;
    box-shadow: 0 0 25px rgba(0, 255, 255, 0.3);
}

textarea::placeholder {
    color: rgba(138, 43, 226, 0.5);
}

.action-btn {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    border: 1px solid rgba(138, 43, 226, 0.5);
    background: rgba(25, 25, 45, 0.8);
    color: #d4b3ff;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
}

.action-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at center, rgba(138, 43, 226, 0.2) 0%, transparent 70%);
    opacity: 0;
    transition: opacity 0.3s;
}

.action-btn:hover {
    background: rgba(138, 43, 226, 0.2);
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.3);
    border-color: #8a2be2;
}

.action-btn:hover::before {
    opacity: 1;
}

.send-btn {
    background: linear-gradient(135deg, #8a2be2, #00ffff);
    color: white;
    font-weight: 700;
    border: none;
}

.send-btn:hover {
    background: linear-gradient(135deg, #00ffff, #8a2be2);
    transform: scale(1.1) rotate(5deg);
}

/* Continue Button for Paused AI Responses */
.continue-button-container {
    position: absolute;
    bottom: 12px;
    right: 12px;
    display: none;
    z-index: 100;
}

.continue-ai-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 14px;
    background: linear-gradient(135deg, #00b09b, #96c93d);
    color: white;
    border: none;
    border-radius: 20px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 600;
    box-shadow: 0 4px 12px rgba(0, 176, 155, 0.4);
    transition: all 0.3s;
}

.continue-ai-btn:hover {
    background: linear-gradient(135deg, #96c93d, #00b09b);
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(0, 176, 155, 0.6);
}

.continue-ai-btn:active {
    transform: translateY(0);
}

.action-btn.active {
    background: linear-gradient(135deg, #ff0064, #ff4081);
    color: white;
    border-color: #ff0064;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(255, 0, 100, 0.7);
    }
    70% {
        box-shadow: 0 0 0 10px rgba(255, 0, 100, 0);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(255, 0, 100, 0);
    }
}

/* Attachment Dropdown */
.attachment-dropdown {
    position: absolute;
    bottom: 60px;
    left: 0;
    background: rgba(25, 25, 45, 0.95);
    border: 1px solid #8a2be2;
    border-radius: 12px;
    padding: 8px;
    display: none;
    flex-direction: column;
    gap: 4px;
    min-width: 180px;
    box-shadow: 0 8px 30px rgba(138, 43, 226, 0.25);
    z-index: 1000;
    backdrop-filter: blur(10px);
}

.attachment-dropdown.show {
    display: flex;
}

.attachment-option {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 14px;
    color: #d4b3ff;
    background: none;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    text-align: left;
    font-size: 0.9rem;
    transition: all 0.2s;
    border: 1px solid transparent;
}

.attachment-option:hover {
    background: rgba(138, 43, 226, 0.2);
    color: #e0d6ff;
    border-color: #8a2be2;
    transform: translateX(5px);
}

/* Voice Recognition Feedback - IMPROVED */
.voice-feedback {
    position: fixed;
    bottom: 120px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, rgba(138, 43, 226, 0.9), rgba(0, 255, 255, 0.8));
    color: white;
    padding: 16px 28px;
    border-radius: 16px;
    display: flex;
    align-items: center;
    gap: 12px;
    z-index: 1000;
    animation: slideUp 0.3s ease;
    box-shadow: 0 6px 25px rgba(138, 43, 226, 0.4);
    font-weight: 500;
    max-width: 85%;
    word-break: break-word;
    backdrop-filter: blur(10px);
    border: 1px solid #8a2be2;
    font-family: 'SF Mono', monospace;
}

.voice-feedback .pulse-icon {
    animation: pulse 1.5s infinite;
    color: #00ffff;
}

@keyframes slideUp {
    from {
        opacity: 0;
        transform: translate(-50%, 20px);
    }
    to {
        opacity: 1;
        transform: translate(-50%, 0);
    }
}

/* Modals */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.92);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    padding: 20px;
    backdrop-filter: blur(5px);
}

.modal.active {
    display: flex;
    animation: fadeIn 0.3s ease;
}

.modal-content {
    background: rgba(25, 25, 45, 0.95);
    border-radius: 20px;
    padding: 30px;
    max-width: 500px;
    width: 100%;
    max-height: 85vh;
    overflow-y: auto;
    position: relative;
    box-shadow: 0 10px 40px rgba(138, 43, 226, 0.3);
    border: 1px solid #8a2be2;
    backdrop-filter: blur(10px);
}

.modal-close {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(138, 43, 226, 0.2);
    border: 1px solid #8a2be2;
    color: #d4b3ff;
    font-size: 1.2rem;
    cursor: pointer;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    transition: all 0.2s;
}

.modal-close:hover {
    background: rgba(138, 43, 226, 0.4);
    color: #ffffff;
    border-color: #00ffff;
    transform: scale(1.1) rotate(90deg);
    box-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
}

.modal-title {
    margin-bottom: 24px;
    font-size: 1.3rem;
    color: #00ffff;
    padding-right: 40px;
    text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
    background: linear-gradient(90deg, #8a2be2, #00ffff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

/* Camera Modal */
.camera-preview {
    width: 100%;
    aspect-ratio: 4/3;
    background: #000;
    border-radius: 12px;
    overflow: hidden;
    margin-bottom: 20px;
    border: 2px solid #8a2be2;
    box-shadow: 0 0 25px rgba(138, 43, 226, 0.3);
    position: relative;
}

.camera-preview::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(45deg, transparent 48%, rgba(138, 43, 226, 0.1) 50%, transparent 52%);
    background-size: 50px 50px;
    animation: scan 2s linear infinite;
    pointer-events: none;
    z-index: 1;
}

@keyframes scan {
    0% { background-position: 0 -50px; }
    100% { background-position: 0 0; }
}

video {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.camera-controls {
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
}

.camera-btn {
    padding: 12px 24px;
    background: linear-gradient(135deg, #8a2be2, #9400d3);
    color: white;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    transition: all 0.2s;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    border: 1px solid #8a2be2;
}

.camera-btn:hover {
    background: linear-gradient(135deg, #9400d3, #8a2be2);
    transform: translateY(-2px);
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.5);
}

.camera-btn.secondary {
    background: rgba(138, 43, 226, 0.2);
    color: #d4b3ff;
    border: 1px solid rgba(138, 43, 226, 0.5);
}

.camera-btn.secondary:hover {
    background: rgba(138, 43, 226, 0.4);
    color: white;
}

/* File Upload */
.upload-area {
    padding: 40px 20px;
    border: 2px dashed #8a2be2;
    border-radius: 16px;
    text-align: center;
    cursor: pointer;
    margin-bottom: 20px;
    transition: all 0.3s ease;
    background: rgba(138, 43, 226, 0.05);
    position: relative;
    overflow: hidden;
}

.upload-area:hover {
    background: rgba(138, 43, 226, 0.1);
    border-color: #00ffff;
    transform: translateY(-2px);
    box-shadow: 0 0 25px rgba(138, 43, 226, 0.3);
}

.upload-area::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    transition: left 0.6s;
}

.upload-area:hover::before {
    left: 100%;
}

.upload-area i {
    font-size: 3.5rem;
    color: #8a2be2;
    margin-bottom: 16px;
    opacity: 0.9;
    text-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
}

.upload-area h3 {
    margin-bottom: 8px;
    color: #00ffff;
    text-shadow: 0 0 8px rgba(0, 255, 255, 0.5);
}

.upload-area p {
    color: #d4b3ff;
    font-size: 0.9rem;
}

.file-preview {
    max-width: 100%;
    max-height: 200px;
    border-radius: 12px;
    margin: 16px auto;
    display: block;
    border: 2px solid #8a2be2;
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.3);
}

.description-input {
    width: 100%;
    padding: 14px;
    border: 1px solid rgba(138, 43, 226, 0.5);
    background: rgba(25, 25, 45, 0.8);
    color: #e0d6ff;
    border-radius: 10px;
    margin-top: 16px;
    resize: none;
    font-family: 'Fira Code', monospace;
    font-size: 0.95rem;
    transition: border 0.2s;
}

.description-input:focus {
    border-color: #00ffff;
    outline: none;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
}

/* Notes Modal */
.notes-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
    max-height: 300px;
    overflow-y: auto;
    margin: 20px 0;
    padding: 5px;
}

.note-item {
    padding: 18px;
    background: rgba(35, 35, 55, 0.8);
    border-radius: 12px;
    cursor: pointer;
    transition: all 0.2s;
    border: 1px solid transparent;
}

.note-item:hover {
    background: rgba(138, 43, 226, 0.15);
    transform: translateY(-2px);
    border-color: #8a2be2;
    box-shadow: 0 5px 15px rgba(138, 43, 226, 0.2);
}

.note-item.selected {
    background: rgba(138, 43, 226, 0.25);
    border: 1px solid #8a2be2;
    box-shadow: 0 5px 20px rgba(138, 43, 226, 0.3);
}

.note-title {
    font-weight: 600;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 10px;
    color: #00ffff;
}

.note-title i {
    color: #8a2be2;
}

.note-preview {
    font-size: 0.9rem;
    color: #d4b3ff;
    line-height: 1.5;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
}

/* Thinking Animation */
.thinking {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 20px;
    background: rgba(25, 25, 45, 0.9);
    border: 1px solid #8a2be2;
    border-radius: 20px;
    max-width: 85%;
    align-self: flex-start;
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.2);
    position: relative;
    overflow: hidden;
}

.thinking::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: linear-gradient(45deg, transparent 30%, rgba(138, 43, 226, 0.1) 50%, transparent 70%);
    animation: shine 3s infinite;
}

.thinking-dots {
    display: flex;
    gap: 4px;
}

.thinking-dots span {
    width: 8px;
    height: 8px;
    background: #00ffff;
    border-radius: 50%;
    animation: bounce 1.4s infinite;
    box-shadow: 0 0 8px #00ffff;
    position: relative;
    z-index: 1;
}

.thinking-dots span:nth-child(2) { animation-delay: 0.2s; }
.thinking-dots span:nth-child(3) { animation-delay: 0.4s; }

@keyframes shine {
    0% { transform: translateX(-100%) translateY(-100%) rotate(45deg); }
    100% { transform: translateX(100%) translateY(100%) rotate(45deg); }
}

/* Toast */
.toast {
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #8a2be2, #00ffff);
    color: white;
    padding: 14px 28px;
    border-radius: 12px;
    z-index: 1000;
    animation: fadeInOut 3s ease;
    box-shadow: 0 4px 20px rgba(138, 43, 226, 0.4);
    font-weight: 700;
    border: 1px solid #8a2be2;
    font-family: 'SF Mono', monospace;
    backdrop-filter: blur(5px);
}

/* Animations */
@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes bounce {
    0%, 80%, 100% { transform: scale(0); }
    40% { transform: scale(1); }
}

@keyframes fadeInOut {
    0%, 100% { opacity: 0; transform: translate(-50%, 20px); }
    15%, 85% { opacity: 1; transform: translate(-50%, 0); }
}

/* Techy Glow Effects */
.glow {
    text-shadow: 0 0 12px rgba(138, 43, 226, 0.8);
}


/* Reset & Base */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'SF Mono', 'Fira Code', 'Roboto Mono', monospace, sans-serif;
    background: #0a0a14;
    color: #e0e0ff;
    min-height: 100vh;
    overflow-x: hidden;
    background-image: 
        radial-gradient(circle at 10% 20%, rgba(138, 43, 226, 0.08) 0%, transparent 25%),
        radial-gradient(circle at 90% 80%, rgba(0, 255, 255, 0.06) 0%, transparent 25%),
        linear-gradient(135deg, #0a0a14 0%, #121225 100%);
}

/* Grid Background Effect */
body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        linear-gradient(rgba(138, 43, 226, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(138, 43, 226, 0.05) 1px, transparent 1px);
    background-size: 50px 50px;
    z-index: -1;
    pointer-events: none;
}

/* Layout */
.app-container {
    display: flex;
    height: 100vh;
    position: relative;
}

/* Sidebar - FIXED: Slide properly without obstructing */
.sidebar {
    width: 280px;
    background: rgba(18, 18, 37, 0.95);
    border-right: 1px solid #8a2be2;
    display: flex;
    flex-direction: column;
    position: fixed;
    left: -280px;
    top: 0;
    bottom: 0;
    transition: transform 0.3s ease;
    z-index: 1000;
    box-shadow: 0 0 30px rgba(138, 43, 226, 0.15);
    backdrop-filter: blur(10px);
    transform: translateX(-100%);
}

.sidebar.active {
    transform: translateX(0);
    box-shadow: 4px 0 25px rgba(138, 43, 226, 0.2);
}

.sidebar-header {
    padding: 20px;
    border-bottom: 1px solid #00ffff;
    background: rgba(10, 10, 20, 0.8);
}

.nav-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px 20px;
    color: #b19cd9;
    text-decoration: none;
    transition: all 0.2s;
    border-radius: 8px;
    margin: 4px 0;
    border: 1px solid transparent;
    position: relative;
    overflow: hidden;
}

.nav-item::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    height: 100%;
    width: 3px;
    background: linear-gradient(to bottom, #8a2be2, #00ffff);
    transform: translateX(-100%);
    transition: transform 0.3s;
}

.nav-item:hover {
    background: rgba(138, 43, 226, 0.1);
    color: #d4b3ff;
    border-color: #8a2be2;
    box-shadow: 0 0 15px rgba(138, 43, 226, 0.2);
}

.nav-item:hover::before {
    transform: translateX(0);
}

.new-chat-btn {
    width: 100%;
    margin-top: 20px;
    padding: 14px;
    background: linear-gradient(135deg, #8a2be2, #9400d3);
    color: white;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.4);
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
}

.new-chat-btn::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -60%;
    width: 50px;
    height: 200%;
    background: rgba(255, 255, 255, 0.1);
    transform: rotate(30deg);
    transition: all 0.6s;
}

.new-chat-btn:hover {
    background: linear-gradient(135deg, #9400d3, #8a2be2);
    box-shadow: 0 0 30px rgba(138, 43, 226, 0.6);
    transform: translateY(-2px);
}

.new-chat-btn:hover::after {
    left: 120%;
}

.chat-history {
    flex: 1;
    padding: 20px;
    overflow-y: auto;
}

.chat-item {
    padding: 12px;
    margin: 8px 0;
    background: rgba(25, 25, 45, 0.8);
    border-radius: 10px;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
    border: 1px solid rgba(138, 43, 226, 0.3);
    overflow: hidden;
}

.chat-item:hover {
    background: rgba(138, 43, 226, 0.1);
    border-color: #8a2be2;
    box-shadow: 0 0 15px rgba(138, 43, 226, 0.2);
    transform: translateX(5px);
}

/* DELETE BUTTON ALWAYS VISIBLE ON MOBILE */
.chat-item .delete-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(255, 0, 100, 0.2);
    border: 1px solid #ff0064;
    color: #ff66a3;
    width: 28px;
    height: 28px;
    border-radius: 6px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    opacity: 1; /* Always visible on mobile */
    transition: all 0.2s;
    font-size: 0.9rem;
    z-index: 2;
}

.chat-item .delete-btn:hover {
    background: rgba(255, 0, 100, 0.4);
    transform: scale(1.1);
    box-shadow: 0 0 10px rgba(255, 0, 100, 0.3);
}

/* On desktop, hide by default, show on hover */
@media (min-width: 769px) {
    .chat-item .delete-btn {
        opacity: 0;
    }
    
    .chat-item:hover .delete-btn {
        opacity: 1;
    }
}

/* Mobile overlay - FIXED: Proper z-index and behavior */
.sidebar-overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.7);
    z-index: 999;
    animation: fadeIn 0.3s ease;
    backdrop-filter: blur(3px);
}

.sidebar-overlay.active {
    display: block;
}

/* Main Chat Area - FIXED: No shift when sidebar opens on mobile */
.main-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    height: 100vh;
    transition: transform 0.3s ease;
    background: #0a0a14;
    position: relative;
    width: 100%;
}

/* When sidebar is active on mobile, slide main content */
.sidebar.active ~ .main-content {
    transform: translateX(280px);
}

.chat-header {
    padding: 16px 24px;
    background: rgba(18, 18, 37, 0.95);
    border-bottom: 1px solid #00ffff;
    display: flex;
    align-items: center;
    gap: 16px;
    position: sticky;
    top: 0;
    z-index: 100;
    backdrop-filter: blur(10px);
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
}

.menu-toggle {
    background: none;
    border: 1px solid #8a2be2;
    color: #8a2be2;
    font-size: 1.2rem;
    cursor: pointer;
    padding: 8px;
    border-radius: 8px;
    transition: all 0.2s;
    width: 40px;
    height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
    z-index: 1001; /* Above sidebar */
}

.menu-toggle::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(45deg, transparent 30%, rgba(138, 43, 226, 0.1) 50%, transparent 70%);
    transform: translateX(-100%);
    transition: transform 0.6s;
}

.menu-toggle:hover {
    background: rgba(138, 43, 226, 0.1);
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.3);
    color: #d4b3ff;
}

.menu-toggle:hover::before {
    transform: translateX(100%);
}

.chat-title {
    font-size: 1.1rem;
    font-weight: 600;
    color: #00ffff;
    text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
    background: linear-gradient(90deg, #8a2be2, #00ffff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

/* Chat Messages */
.chat-messages {
    flex: 1;
    padding: 24px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 20px;
    scroll-behavior: smooth;
}

/* AI MESSAGE STYLING (NO BOX) */
.ai-message {
    align-self: flex-start;
    background: transparent !important;
    border: none !important;
    box-shadow: none !important;
    padding: 0 !important;
    max-width: 100% !important;
    margin: 10px 0 20px 0;
    position: relative;
    width: 100%;
}

/* User messages keep their styling */
.user-message {
    align-self: flex-end;
    background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(148, 0, 211, 0.3));
    color: #e0d6ff;
    position: relative;
    border-color: #8a2be2;
    box-shadow: 0 0 20px rgba(138, 43, 226, 0.2);
    border-left: 4px solid #8a2be2;
    border-radius: 20px;
    padding: 16px 20px;
    max-width: 85%;
    margin: 10px 0;
}

/* AI content as plain text */
.ai-content {
    font-size: 1rem;
    color: #e0e0ff;
    line-height: 1.6;
    padding: 0;
    background: transparent;
    border: none;
    box-shadow: none;
    width: 100%;
}

/* Headers in AI content */
.ai-content h1 { 
    font-size: 1.8rem; 
    margin: 25px 0 15px; 
    color: #8a2be2;
    padding-bottom: 8px;
    border-bottom: 2px solid rgba(138, 43, 226, 0.3);
}
.ai-content h2 { 
    font-size: 1.5rem; 
    margin: 22px 0 12px; 
    color: #d4b3ff;
}
.ai-content h3 { 
    font-size: 1.3rem; 
    margin: 20px 0 10px; 
    color: #a3d9ff;
}
.ai-content p { 
    margin-bottom: 18px; 
    color: #d0d0ff;
}
.ai-content ul, .ai-content ol { 
    margin: 15px 0 15px 25px; 
}
.ai-content li { 
    margin-bottom: 8px; 
    color: #c0c0ff;
}

/* CODE BLOCK WITH STICKY COPY BUTTON */
.code-block-wrapper {
    position: relative;
    margin: 25px 0;
    border-radius: 12px;
    overflow: hidden;
    border: 2px solid #8a2be2;
    background: #121225;
    box-shadow: 0 0 25px rgba(138, 43, 226, 0.25);
    max-height: 500px;
    display: flex;
    flex-direction: column;
}

/* Sticky header that stays at top during scroll */
.code-header {
    position: sticky;
    top: 0;
    z-index: 100;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: rgba(138, 43, 226, 0.25);
    padding: 12px 16px;
    border-bottom: 1px solid #00ffff;
    min-height: 48px;
    backdrop-filter: blur(10px);
}

.code-language {
    font-size: 0.9rem;
    color: #00ffff;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
    font-family: 'Fira Code', monospace;
}

/* Remove retry button from AI messages */
.ai-message .retry-btn-outside {
    display: none !important;
}

/* RETRY BUTTON ONLY FOR USER MESSAGES */
.user-message .retry-btn-outside {
    position: absolute;
    bottom: -12px;
    left: -12px;
    background: linear-gradient(135deg, #ff0064, #ff4081);
    color: white;
    border: none;
    border-radius: 50%;
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 10;
    box-shadow: 0 4px 12px rgba(255, 0, 100, 0.4);
    font-size: 1rem;
    opacity: 1;
    transition: all 0.3s;
    border: 1px solid #ff66a3;
}

.retry-btn-outside:hover {
    background: linear-gradient(135deg, #ff4081, #ff0064);
    transform: scale(1.1);
    box-shadow: 0 6px 16px rgba(255, 0, 100, 0.6);
}

/* USER MESSAGE ACTIONS */
.user-message .message-actions {
    position: absolute;
    bottom: -12px;
    right: 12px;
    background: rgba(138, 43, 226, 0.9);
    border: 1px solid #8a2be2;
    border-radius: 8px;
    padding: 4px;
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 10;
    backdrop-filter: blur(5px);
}

.ai-message .message-actions {
    position: absolute;
    top: -12px;
    right: 12px;
    background: rgba(0, 255, 255, 0.9);
    border: 1px solid #00ffff;
    border-radius: 8px;
    padding: 4px;
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 10;
    backdrop-filter: blur(5px);
}

.message:hover .message-actions {
    opacity: 1;
}

/* Always show actions for editing */
.message.editing .message-actions {
    opacity: 1;
}

.message-action-btn {
    width: 28px;
    height: 28px;
    border-radius: 6px;
    border: none;
    background: rgba(255, 255, 255, 0.15);
    color: #e0e0ff;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s;
    backdrop-filter: blur(5px);
}

.message-action-btn:hover {
    background: rgba(255, 255, 255, 0.3);
    color: white;
    transform: scale(1.1);
}

/* Message Editing */
.message-editing {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: inherit;
    border-radius: 20px;
    padding: 16px 20px;
    display: none;
    flex-direction: column;
    gap: 12px;
    z-index: 20;
}

.message.editing .message-editing {
    display: flex;
}

.edit-textarea {
    flex: 1;
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #8a2be2;
    border-radius: 12px;
    padding: 12px;
    color: #e0d6ff;
    font-family: 'Fira Code', monospace;
    font-size: 1rem;
    resize: none;
    outline: none;
    min-height: 60px;
    box-shadow: 0 0 15px rgba(138, 43, 226, 0.3);
    transition: all 0.3s;
}

.edit-textarea:focus {
    border-color: #00ffff;
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
}

.edit-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
}

.edit-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.2s;
    font-family: 'SF Mono', monospace;
}

.edit-save {
    background: linear-gradient(135deg, #8a2be2, #00ffff);
    color: white;
    border: 1px solid #8a2be2;
}

.edit-save:hover {
    background: linear-gradient(135deg, #00ffff, #8a2be2);
    box-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
    transform: translateY(-2px);
}

.edit-cancel {
    background: rgba(255, 255, 255, 0.1);
    color: #00ffff;
    border: 1px solid #00ffff;
}

.edit-cancel:hover {
    background: rgba(0, 255, 255, 0.2);
}

/* Inline code styling */
.ai-content code:not(pre code) {
    background: rgba(138, 43, 226, 0.15);
    padding: 2px 6px;
    border-radius: 4px;
    font-family: 'Fira Code', monospace;
    color: #00ffff;
    border: 1px solid rgba(0, 255, 255, 0.3);
}

/* Rest of your CSS remains the same... */

/* Media Queries - RESPONSIVE DESIGN */
@media (max-width: 768px) {
    .sidebar {
        width: 85%;
        max-width: 300px;
        left: -280px;
    }
    
    .sidebar.active {
        left: 0;
    }
    
    .main-content {
        margin-left: 0;
    }
    
    .message, .user-message {
        max-width: 90%;
    }
    
    .chat-header {
        padding: 12px 16px;
    }
    
    .chat-messages {
        padding: 16px;
    }
    
    .input-container {
        padding: 12px 16px;
    }
    
    textarea {
        padding: 12px 16px;
        font-size: 0.95rem;
    }
    
    .action-btn {
        width: 44px;
        height: 44px;
    }
    
    .modal-content {
        padding: 20px;
        margin: 10px;
        max-height: 90vh;
    }
    
    .upload-area {
        padding: 30px 15px;
    }
    
    .upload-area i {
        font-size: 2.5rem;
    }
    
    .camera-controls {
        flex-direction: column;
    }
    
    .camera-btn {
        width: 100%;
        justify-content: center;
    }
    
    .attachment-dropdown {
        bottom: 55px;
        left: -20px;
        min-width: 160px;
    }
    
    .code-block-wrapper {
        margin: 12px -8px;
        border-radius: 8px;
    }
    
    .code-block {
        padding: 12px;
        font-size: 0.85rem;
    }
    
    pre {
        font-size: 0.85rem;
    }
    
    .voice-feedback {
        bottom: 110px;
        max-width: 90%;
        font-size: 0.9rem;
        padding: 12px 24px;
    }
    
    /* Delete button always visible on mobile */
    .chat-item .delete-btn {
        opacity: 1;
    }
    
    /* AI content adjustments for mobile */
    .ai-content {
        font-size: 0.95rem;
    }
    
    .ai-content h1 { 
        font-size: 1.5rem; 
    }
    .ai-content h2 { 
        font-size: 1.3rem; 
    }
    .ai-content h3 { 
        font-size: 1.1rem; 
    }
}

@media (min-width: 769px) and (max-width: 1024px) {
    .sidebar {
        width: 250px;
        left: -250px;
    }
    
    .sidebar.active {
        left: 0;
    }
    
    .main-content {
        margin-left: 0;
    }
    
    .message, .user-message {
        max-width: 75%;
    }
}

@media (min-width: 1025px) {
    .sidebar {
        position: fixed;
        left: 0;
        width: 280px;
        z-index: 100;
    }
    
    .menu-toggle {
        display: none;
    }
    
    .main-content {
        margin-left: 280px;
    }
    
    .sidebar-overlay {
        display: none !important;
    }
    
    /* Ensure AI content doesn't exceed container */
    .ai-content {
        max-width: 900px;
    }
    
    .message, .user-message {
        max-width: 75%;
    }
}

/* Matrix Rain Effect for Background (Optional) */
.matrix-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    opacity: 0.03;
    z-index: -2;
}

.image-attachment {
    background: rgba(255, 107, 107, 0.1);
    border: 1px solid rgba(255, 107, 107, 0.2);
    border-radius: 8px;
    padding: 12px;
    margin-top: 12px;
}

.image-attachment img {
    transition: transform 0.2s;
}

.image-attachment img:hover {
    transform: scale(1.02);
}

.message.user-message .image-attachment {
    background: rgba(138, 43, 226, 0.1);
    border: 1px solid rgba(138, 43, 226, 0.2);
}

.image-modal img {
    box-shadow: 0 4px 20px rgba(0,0,0,0.5);
}

/* File attachment styling */
[class*="attachment"] {
    transition: all 0.2s;
}

[class*="attachment"]:hover {
    transform: translateY(-2px);
}


.notes-selection-mode .note-select-item {
    display: flex;
    flex-direction: column;
    padding: 16px;
    margin-bottom: 12px;
    background: rgba(138, 43, 226, 0.1);
    border-radius: 8px;
    border: 1px solid rgba(138, 43, 226, 0.2);
    cursor: pointer;
    transition: all 0.3s ease;
    position: relative;
}

.notes-selection-mode .note-select-item:hover {
    background: rgba(138, 43, 226, 0.2);
    border-color: rgba(138, 43, 226, 0.5);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(138, 43, 226, 0.2);
}

.notes-selection-mode .note-select-item.selected {
    background: rgba(138, 43, 226, 0.25);
    border-color: #8a2be2;
    box-shadow: 0 0 15px rgba(138, 43, 226, 0.4);
}

.notes-selection-mode .note-select-header {
    display: flex;
    align-items: flex-start;
    margin-bottom: 12px;
}

.notes-selection-mode .note-select-checkbox {
    margin-right: 12px;
    margin-top: 3px;
}

.notes-selection-mode .note-select-content {
    flex: 1;
}

.notes-selection-mode .note-select-title {
    font-weight: 700;
    margin-bottom: 4px;
    color: white;
    font-size: 1.05rem;
    display: flex;
    align-items: center;
    gap: 8px;
}

.notes-selection-mode .note-select-title i {
    color: #00ffff;
}

.notes-selection-mode .note-select-preview {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.7);
    max-height: 60px;
    overflow: hidden;
    text-overflow: ellipsis;
    line-height: 1.4;
    margin-top: 4px;
    padding-left: 24px;
}

.notes-selection-mode .note-topics-section {
    margin-top: 12px;
    padding: 12px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 6px;
    border-left: 3px solid #00ffff;
    display: none;
}

.notes-selection-mode .note-select-item.selected .note-topics-section {
    display: block;
}

.notes-selection-mode .topics-title {
    font-size: 0.9rem;
    color: #a0a8d6;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 6px;
}

.notes-selection-mode .topics-title i {
    color: #00ffff;
}

.notes-selection-mode .topics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 8px;
    margin-top: 8px;
}

.notes-selection-mode .topic-item {
    display: flex;
    align-items: center;
    padding: 6px 10px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
    transition: all 0.2s ease;
    cursor: pointer;
}

.notes-selection-mode .topic-item:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: translateY(-1px);
}

.notes-selection-mode .topic-item.selected-topic {
    background: rgba(0, 255, 255, 0.2);
    border: 1px solid #00ffff;
}

.notes-selection-mode .topic-checkbox {
    margin-right: 8px;
}

.notes-selection-mode .topic-name {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.9);
}

.notes-selection-mode .topic-count {
    margin-left: auto;
    font-size: 0.75rem;
    color: #6b7299;
    background: rgba(255, 255, 255, 0.1);
    padding: 2px 6px;
    border-radius: 10px;
}

.notes-selection-mode .custom-topic-input {
    margin-top: 12px;
    display: flex;
    gap: 8px;
}

.notes-selection-mode .custom-topic-input input {
    flex: 1;
    padding: 8px 12px;
    background: rgba(255, 255, 255, 0.08);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 6px;
    color: white;
    font-size: 0.9rem;
}

.notes-selection-mode .custom-topic-input input:focus {
    outline: none;
    border-color: #00ffff;
    background: rgba(255, 255, 255, 0.12);
}

.notes-selection-mode .custom-topic-input button {
    padding: 8px 16px;
    background: linear-gradient(135deg, #00ffff, #0099cc);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 0.85rem;
    font-weight: 600;
    transition: all 0.3s ease;
}

.notes-selection-mode .custom-topic-input button:hover {
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(0, 255, 255, 0.3);
}

.notes-selection-mode .note-select-actions {
    display: flex;
    flex-direction: column;
    gap: 5px;
    margin-left: 10px;
}

.notes-selection-mode .note-send-btn,
.notes-selection-mode .note-attach-btn {
    background: linear-gradient(135deg, #8a2be2, #00ffff);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 700;
    transition: all 0.3s ease;
    font-size: 0.95rem;
    letter-spacing: 0.3px;
}

.notes-selection-mode .note-send-btn:hover,
.notes-selection-mode .note-attach-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 8px 20px rgba(138, 43, 226, 0.4);
}

.notes-selection-mode .note-send-btn:disabled,
.notes-selection-mode .note-attach-btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.notes-selection-mode .notes-modal-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid rgba(255, 255, 255, 0.15);
}

.notes-selection-mode .selected-count {
    color: #00ffff;
    font-weight: 700;
    font-size: 1.1rem;
    background: rgba(0, 255, 255, 0.1);
    padding: 6px 12px;
    border-radius: 20px;
    border: 1px solid rgba(0, 255, 255, 0.3);
}

.notes-selection-mode .notes-list-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 15px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.15);
}

.notes-selection-mode .notes-list-header h3 {
    margin: 0;
    color: white;
    font-size: 1.3rem;
    display: flex;
    align-items: center;
    gap: 10px;
}

/* Note attachment preview in chat input area */
.note-attachment-preview {
    margin-top: 15px;
    padding: 15px;
    background: linear-gradient(135deg, rgba(138, 43, 226, 0.1), rgba(0, 255, 255, 0.1));
    border-radius: 10px;
    border: 1px solid rgba(138, 43, 226, 0.3);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

.note-attachment-preview h4 {
    margin-top: 0;
    color: #00ffff;
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 15px;
}

.note-attachment-list {
    list-style: none;
    padding: 0;
    margin: 10px 0 0 0;
}

.note-attachment-item {
    padding: 12px;
    margin-bottom: 8px;
    background: rgba(255, 255, 255, 0.05);
    border-radius: 6px;
    border-left: 4px solid #8a2be2;
    transition: all 0.3s ease;
}

.note-attachment-item:hover {
    background: rgba(255, 255, 255, 0.08);
    transform: translateX(5px);
}

.note-attachment-title {
    font-weight: 600;
    color: white;
    font-size: 0.95rem;
    display: flex;
    align-items: center;
    gap: 8px;
}

.note-attachment-topics {
    margin-top: 6px;
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.topic-tag {
    background: rgba(0, 255, 255, 0.2);
    color: #00ffff;
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 600;
}

.note-attachment-content {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.7);
    margin-top: 8px;
    line-height: 1.4;
}

.note-topic-badge {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    background: rgba(0, 255, 255, 0.15);
    color: #00ffff;
    padding: 3px 8px;
    border-radius: 12px;
    font-size: 0.75rem;
    font-weight: 600;
    margin-left: 8px;
}

.empty-topics {
    font-size: 0.85rem;
    color: #6b7299;
    font-style: italic;
    padding: 10px;
    text-align: center;
    background: rgba(255, 255, 255, 0.03);
    border-radius: 6px;
    border: 1px dashed rgba(255, 255, 255, 0.1);
}

.extract-topics-btn {
    margin-top: 10px;
    padding: 6px 12px;
    background: rgba(255, 215, 0, 0.1);
    border: 1px solid rgba(255, 215, 0, 0.3);
    color: #ffd700;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.8rem;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 6px;
}

.extract-topics-btn:hover {
    background: rgba(255, 215, 0, 0.2);
    transform: scale(1.05);
}
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar Overlay for Mobile -->
        <div id="sidebarOverlay" class="sidebar-overlay"></div>
        
        <!-- Sidebar -->
        <aside id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <nav style="display: flex; flex-direction: column; gap: 4px; margin-top: 12px;">
                    <a href="#" class="nav-item" onclick="navigateTo('homepage.html')">
                        <i class="fas fa-home"></i> Home
                    </a>
                  
                </nav>
                <button id="newChatBtn" class="new-chat-btn">
                    <i class="fas fa-plus"></i> New Chat
                </button>
            </div>
            <div class="chat-history">
                <h3 style="color: #a0a8d6; font-size: 0.9rem; margin-bottom: 16px;">
                    <i class="fas fa-history"></i> Recent Chats
                </h3>
                <div id="chatList"></div>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="chat-header">
                <button id="menuToggle" class="menu-toggle">
                    <i class="fas fa-bars"></i>
                </button>
                <div class="chat-title">
                    <i class="fas fa-robot"></i> Student Companion AI
                </div>
                <div id="currentChatTitle" style="margin-left: auto; color: #a0a8d6; font-size: 0.9rem;">
                    <i class="fas fa-hashtag"></i> <span>New Chat</span>
                </div>
            </header>

            <div id="chatMessages" class="chat-messages"></div>

            <div class="input-container">
                <div class="input-wrapper">
                    <div style="position: relative;">
                        <button id="attachBtn" class="action-btn">
                            <i class="fas fa-paperclip"></i>
                        </button>
                        <div id="attachmentMenu" class="attachment-dropdown">
                            <button class="attachment-option" data-type="file">
                                <i class="fas fa-file"></i> Attach File
                            </button>
                            <button class="attachment-option" data-type="camera">
                                <i class="fas fa-camera"></i> Take Photo
                            </button>
                            <button class="attachment-option" data-type="photo">
                                <i class="fas fa-image"></i> Choose Photo
                            </button>
                            <button class="attachment-option" data-type="notes">
                                <i class="fas fa-sticky-note"></i> Ask about Notes
                            </button>
                        </div>
                    </div>
                    
                    <textarea 
                        id="messageInput" 
                        placeholder="Message Student Companion AI..." 
                        rows="1"
                    ></textarea>
                    
                    <button id="micBtn" class="action-btn">
                        <i class="fas fa-microphone"></i>
                    </button>
                    
                    <button id="sendBtn" class="action-btn send-btn">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </main>
    </div>

    <!-- Voice Feedback -->
    <div id="voiceFeedback" class="voice-feedback" style="display: none;">
        <i class="fas fa-microphone pulse-icon"></i>
        <span id="voiceText">Listening... Speak now</span>
    </div>

    <!-- Modals -->
    <div id="cameraModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" data-modal="camera">&times;</button>
            <h2 class="modal-title">Take a Photo</h2>
            <div class="camera-preview">
                <video id="cameraVideo" autoplay playsinline></video>
            </div>
            <div class="camera-controls">
                <button id="switchCamera" class="camera-btn">
                    <i class="fas fa-sync-alt"></i> Switch Camera
                </button>
                <button id="capturePhoto" class="camera-btn">
                    <i class="fas fa-camera"></i> Capture
                </button>
            </div>
            <canvas id="photoCanvas" style="display: none;"></canvas>
        </div>
    </div>

    <div id="photoModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" data-modal="photo">&times;</button>
            <h2 class="modal-title">Choose Photo</h2>
            <div class="upload-area" onclick="document.getElementById('photoInput').click()">
                <i class="fas fa-cloud-upload-alt"></i>
                <h3>Click to select photo</h3>
                <p>JPG, PNG, GIF (Max: 5MB)</p>
                <input type="file" id="photoInput" accept="image/*" style="display: none;">
            </div>
            <div id="photoPreviewContainer" style="display: none;">
                <img id="photoPreview" class="file-preview">
                <textarea 
                    id="photoDescription" 
                    class="description-input" 
                    placeholder="What do you want the AI to do with this photo?..."
                    rows="3"
                ></textarea>
            </div>
            <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;">
                <button class="camera-btn secondary" data-modal="photo">Cancel</button>
                <button id="usePhoto" class="camera-btn">Use Photo</button>
            </div>
        </div>
    </div>

    <div id="fileModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" data-modal="file">&times;</button>
            <h2 class="modal-title">Upload File</h2>
            <div class="upload-area" onclick="document.getElementById('fileInput').click()">
                <i class="fas fa-file-upload"></i>
                <h3>Click to upload file</h3>
                <p>PDF, DOC, TXT, Images (Max: 5MB)</p>
                <input type="file" id="fileInput" style="display: none;">
            </div>
            <div id="fileInfo" style="display: none;">
                <p style="margin-bottom: 12px; font-weight: 600; color: white;">
                    <i class="fas fa-file" style="color: #3a7bd5;"></i> <span id="fileName"></span>
                </p>
                <textarea 
                    id="fileDescription" 
                    class="description-input" 
                    placeholder="What do you want the AI to do with this file?..."
                    rows="3"
                ></textarea>
            </div>
            <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;">
                <button class="camera-btn secondary" data-modal="file">Cancel</button>
                <button id="uploadFile" class="camera-btn">Upload File</button>
            </div>
        </div>
    </div>

    <div id="notesModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" data-modal="notes">&times;</button>
            <h2 class="modal-title">Select a Note to Ask About</h2>
            <div style="margin-bottom: 20px; color: #a0a8d6; font-size: 0.9rem; line-height: 1.5;">
                <i class="fas fa-info-circle" style="color: #3a7bd5;"></i> 
                Click on a note below to load its content. Then ask the AI anything about that note.
            </div>
            <div id="notesList" class="notes-list"></div>
            <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;">
                <button class="camera-btn secondary" data-modal="notes">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toastContainer"></div>

    <!-- Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>
    
<script>
    // blackbot.js - Student Companion AI Chat Interface - WITH MULTIMODAL FILE ANALYSIS
    // Updated version with shorter welcome messages and improved connection

    // Configuration
    const USE_BACKEND = true;
    const isLocalhost = window.location.hostname === 'localhost' || 
                       window.location.hostname === '127.0.0.1' ||
                       window.location.port === '5500' || 
                       window.location.port === '8080';

    // Backend URLs
    let BACKEND_BASE_URL = '';
    if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        BACKEND_BASE_URL = 'http://localhost:3000';
    } else {
        BACKEND_BASE_URL = 'https://edutrack-2-2ufp.onrender.com';
    }

    const API_URL = `${BACKEND_BASE_URL}/api/chat`;
    const ENABLE_WEBSEARCH = true;
    const SEARCH_API_URL = `${BACKEND_BASE_URL}/api/search`;
    const IMAGE_ANALYSIS_URL = `${BACKEND_BASE_URL}/api/analyze-image`;
    const DOCUMENT_ANALYSIS_URL = `${BACKEND_BASE_URL}/api/analyze-document`;
    const MULTIMODAL_ANALYSIS_URL = `${BACKEND_BASE_URL}/api/analyze-multimodal`;
    const CONNECTION_CHECK_INTERVAL = 10000; // Reduced to 10 seconds
    const MAX_RETRY_ATTEMPTS = 3;

    // Initialize markdown parser
    const md = window.markdownit ? window.markdownit({
        html: false,
        linkify: true,
        typographer: true,
        highlight: function (str, lang) {
            if (window.hljs && lang && hljs.getLanguage(lang)) {
                try {
                    return hljs.highlight(str, { language: lang }).value;
                } catch (err) {
                    console.error('Highlight error:', err);
                }
            }
            return '';
        }
    }) : {
        render: (text) => {
            return text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                       .replace(/\n/g, '<br>')
                       .replace(/`(.*?)`/g, '<code>$1</code>');
        }
    };

    // DOM Elements
    const sidebar = document.getElementById('sidebar');
    const menuToggle = document.getElementById('menuToggle');
    const sidebarOverlay = document.getElementById('sidebarOverlay');
    const newChatBtn = document.getElementById('newChatBtn');
    const messageInput = document.getElementById('messageInput');
    const sendBtn = document.getElementById('sendBtn');
    const micBtn = document.getElementById('micBtn');
    const attachBtn = document.getElementById('attachBtn');
    const attachmentMenu = document.getElementById('attachmentMenu');
    const chatMessages = document.getElementById('chatMessages');
    const chatList = document.getElementById('chatList');
    const currentChatTitle = document.getElementById('currentChatTitle').querySelector('span');
    const voiceFeedback = document.getElementById('voiceFeedback');
    const voiceText = document.getElementById('voiceText');

    // State
    let currentChatId = null;
    let chats = [];
    let currentMessages = [];
    let isTyping = false;
    let isThinking = false;
    let pendingAttachments = [];
    let cameraStream = null;
    let facingMode = 'user';
    let fileProcessingMode = 'separate';
    let awaitingFileDecision = false;
    let typingPaused = false;
    let currentTypingMessage = null;
    let sendButtonMode = 'send';
    let isProcessingMessage = false;

    // Web Search State
    let webSearchEnabled = true;

    // Background Processing State
    let backgroundProcessing = true;
    let backgroundTasks = new Map();
    let offlineMode = false;
    let lastActivityTime = Date.now();

    // Connection Management State
    let backendConnectionStatus = 'unknown';
    let connectionCheckInterval = null;
    let retryAttempts = 0;
    let lastSuccessfulConnection = Date.now();
    let autoReconnectEnabled = true;

    // Voice Recognition State
    let isListening = false;
    let recognition = null;
    let silenceTimer = null;
    let finalTranscript = '';
    let interimTranscript = '';
    let recognitionActive = false;
    let isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Check if voice recognition is supported
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let isVoiceRecognitionSupported = false;
    
    try {
        if (SpeechRecognition) {
            const testRecognition = new SpeechRecognition();
            isVoiceRecognitionSupported = true;
        }
    } catch (e) {
        console.log('Voice recognition not supported:', e);
        isVoiceRecognitionSupported = false;
    }

    // Notes Management State
    let currentNotesInModal = [];
    let availableNotes = [];
    let notesSearchEnabled = true;

    // File Analysis State
    let fileAnalysisInProgress = false;
    let analyzedFiles = new Map();

    // Scroll tracking
    let userScrolledUp = false;
    let scrollToBottomBtn = null;

    // Welcome messages array
    const welcomeMessages = [
        "Hello {name}! I'm Study Buddy, how may I help today?",
        "Hi {name}! Ready to study? What can I assist you with?",
        "Hey {name}! I'm here to help with your studies. What's on your mind?",
        "{name}, your AI study assistant is here! How can I help?",
        "Welcome back {name}! What would you like to learn today?"
    ];

    // Helper function to convert base64 to blob
    function base64ToBlob(base64, mimeType) {
        try {
            const byteCharacters = atob(base64.split(',')[1]);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        } catch (e) {
            console.error('Error converting base64 to blob:', e);
            return null;
        }
    }

    // Helper function to get file type indicator
    function getFileTypeIndicator(fileName, mimeType) {
        if (!fileName) fileName = 'Unknown File';
        const extension = fileName.split('.').pop().toLowerCase();
        
        if (mimeType?.includes('pdf') || extension === 'pdf') {
            return { class: 'file-type-pdf', icon: 'fas fa-file-pdf', text: 'PDF' };
        } else if (mimeType?.includes('word') || extension === 'doc' || extension === 'docx') {
            return { class: 'file-type-doc', icon: 'fas fa-file-word', text: 'DOC' };
        } else if (mimeType?.includes('text') || extension === 'txt') {
            return { class: 'file-type-txt', icon: 'fas fa-file-alt', text: 'TXT' };
        } else if (mimeType?.includes('image') || ['jpg', 'jpeg', 'png', 'gif', 'webp', 'bmp'].includes(extension)) {
            return { class: 'file-type-image', icon: 'fas fa-file-image', text: 'IMG' };
        } else {
            return { class: 'file-type-txt', icon: 'fas fa-file', text: 'FILE' };
        }
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', init);

    async function init() {
        console.log(' Initializing Student Companion AI');
        console.log(' Backend URL:', BACKEND_BASE_URL);
        
        // Get current user
        const currentUser = getCurrentUser();
        if (!currentUser || currentUser === 'Guest') {
            showToast('Please log in to use the chat', 'warning');
            setTimeout(() => {
                window.location.href = 'profile.html';
            }, 2000);
            return;
        }
        
        console.log(' Current user:', currentUser);
        
        // Setup connection indicator
        setupConnectionIndicator();
        
        // Load user data
        const userChatsKey = `studentAI_chats_${currentUser}`;
        try {
            chats = JSON.parse(localStorage.getItem(userChatsKey) || '[]');
            console.log(' Loaded chats:', chats.length);
        } catch (e) {
            chats = [];
        }
        
        // Create or load current chat
        const currentChatKey = `currentChat_${currentUser}`;
        currentChatId = localStorage.getItem(currentChatKey);
        
        if (!currentChatId) {
            currentChatId = `chat_${Date.now()}_${currentUser}`;
            localStorage.setItem(currentChatKey, currentChatId);
        }
        
        // Load messages
        const chatMessagesKey = `chat_${currentUser}_${currentChatId}`;
        try {
            currentMessages = JSON.parse(localStorage.getItem(chatMessagesKey) || '[]');
            console.log(' Loaded messages:', currentMessages.length);
        } catch (e) {
            currentMessages = [];
        }
        
        // Load settings
        loadSettings();
        
        // Load UI
        loadChats();
        renderMessages();
        setupEventListeners();
        
        // Initialize components
        updateSendButton();
        initVoiceRecognition();
        setupScrollTracking();
        setupWebSearchButton();
        setupBackgroundProcessing();
        setupNoteSending();
        
        // Show welcome if no messages
        if (currentMessages.length === 0) {
            await showWelcomeMessage();
        }
        
        // Preload notes for quick access
        await preloadNotes();
        
        scrollToBottom();
        
        // Start backend connection immediately
        await checkAndRestoreBackendConnection(true);
        
        // Start connection monitoring
        startConnectionMonitoring();
    }

    // CONNECTION MANAGEMENT FUNCTIONS
    async function checkAndRestoreBackendConnection(showNotification = true) {
        if (!USE_BACKEND) {
            backendConnectionStatus = 'mock';
            updateConnectionIndicator();
            return false;
        }
        
        try {
            console.log(' Checking backend connection...');
            backendConnectionStatus = 'retrying';
            updateConnectionIndicator();
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 5000);
            
            const response = await fetch(`${BACKEND_BASE_URL}/api/health`, {
                method: 'GET',
                headers: { 
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache',
                    'Accept': 'application/json'
                },
                signal: controller.signal,
                mode: 'cors',
                credentials: 'omit'
            });
            
            clearTimeout(timeoutId);
            
            if (response.ok) {
                console.log(' Backend connection successful');
                backendConnectionStatus = 'connected';
                lastSuccessfulConnection = Date.now();
                retryAttempts = 0;
                updateConnectionIndicator();
                
                if (showNotification && retryAttempts > 0) {
                    showToast(' Backend connected!', 'success');
                }
                return true;
            } else {
                throw new Error(`HTTP ${response.status}`);
            }
            
        } catch (error) {
            console.error(' Backend connection failed:', error.message);
            
            backendConnectionStatus = 'disconnected';
            retryAttempts++;
            updateConnectionIndicator();
            
            if (retryAttempts >= MAX_RETRY_ATTEMPTS) {
                showToast(' Using offline mode. Some features limited.', 'error');
                backendConnectionStatus = 'offline';
                updateConnectionIndicator();
            }
            
            return false;
        }
    }

    function setupConnectionIndicator() {
        const connectionIndicator = document.getElementById('connectionIndicator');
        if (connectionIndicator) connectionIndicator.remove();
        
        const newIndicator = document.createElement('div');
        newIndicator.id = 'connectionIndicator';
        newIndicator.style.cssText = `
            position: fixed;
            top: 10px;
            right: 10px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            z-index: 10000;
            transition: all 0.3s;
            cursor: pointer;
            box-shadow: 0 0 8px currentColor;
        `;
        newIndicator.title = 'Connection status: Checking...';
        newIndicator.addEventListener('click', showConnectionStatusDialog);
        
        document.body.appendChild(newIndicator);
        updateConnectionIndicator();
    }

    function updateConnectionIndicator() {
        const indicator = document.getElementById('connectionIndicator');
        if (!indicator) return;
        
        let statusText = 'Connection status: ';
        let color = 'gray';
        let pulse = false;
        
        switch (backendConnectionStatus) {
            case 'connected':
                color = '#00ff00';
                statusText += 'Connected';
                pulse = true;
                break;
            case 'disconnected':
                color = '#ff0000';
                statusText += 'Disconnected';
                pulse = true;
                break;
            case 'retrying':
                color = '#ff9900';
                statusText += 'Retrying...';
                pulse = true;
                break;
            case 'offline':
                color = '#888888';
                statusText += 'Offline Mode';
                break;
            case 'mock':
                color = '#8a2be2';
                statusText += 'Mock Mode';
                break;
            default:
                color = '#888888';
                statusText += 'Unknown';
        }
        
        indicator.style.background = color;
        indicator.style.boxShadow = `0 0 10px ${color}`;
        indicator.title = statusText + `\nURL: ${BACKEND_BASE_URL}`;
        
        if (pulse) {
            indicator.style.animation = 'pulse 2s infinite';
        } else {
            indicator.style.animation = 'none';
        }
    }

    function showConnectionStatusDialog() {
        const existingDialog = document.querySelector('.connection-dialog');
        if (existingDialog) existingDialog.remove();
        
        const dialog = document.createElement('div');
        dialog.className = 'connection-dialog';
        dialog.style.cssText = `
            position: fixed;
            top: 30px;
            right: 30px;
            background: rgba(25, 25, 40, 0.95);
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 10px;
            padding: 20px;
            z-index: 10001;
            min-width: 300px;
            max-width: 400px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        `;
        
        let statusHTML = '';
        switch (backendConnectionStatus) {
            case 'connected':
                statusHTML = `
                    <h3 style="margin-top: 0; color: #00ff00;"> Connected</h3>
                    <p>Backend server is running properly.</p>
                    <p><small>Server URL: ${BACKEND_BASE_URL}</small></p>
                    <p><small>Last successful: ${new Date(lastSuccessfulConnection).toLocaleTimeString()}</small></p>
                `;
                break;
            case 'disconnected':
            case 'retrying':
                statusHTML = `
                    <h3 style="margin-top: 0; color: #ff9900;"> Connection Issue</h3>
                    <p>Cannot connect to backend server.</p>
                    <p><small>Server URL: ${BACKEND_BASE_URL}</small></p>
                    <p><small>Attempt ${retryAttempts} of ${MAX_RETRY_ATTEMPTS}</small></p>
                `;
                break;
            case 'offline':
                statusHTML = `
                    <h3 style="margin-top: 0; color: #888888;"> Offline Mode</h3>
                    <p>Using offline capabilities.</p>
                    <p><small>Basic features available</small></p>
                    <p><small>Full AI features require backend connection</small></p>
                `;
                break;
            default:
                statusHTML = `
                    <h3 style="margin-top: 0; color: #888888;"> Unknown</h3>
                    <p>Connection status unknown.</p>
                    <p><small>Server URL: ${BACKEND_BASE_URL}</small></p>
                `;
        }
        
        dialog.innerHTML = `
            ${statusHTML}
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button id="testConnectionBtn" style="flex: 1; padding: 8px; background: #8a2be2; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    Test Connection
                </button>
                <button id="closeDialogBtn" style="flex: 1; padding: 8px; background: #444; color: white; border: none; border-radius: 5px; cursor: pointer;">
                    Close
                </button>
            </div>
        `;
        
        document.body.appendChild(dialog);
        
        dialog.querySelector('#testConnectionBtn').addEventListener('click', async () => {
            dialog.querySelector('#testConnectionBtn').innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testing...';
            await checkAndRestoreBackendConnection(true);
            setTimeout(() => {
                dialog.remove();
                showConnectionStatusDialog();
            }, 1000);
        });
        
        dialog.querySelector('#closeDialogBtn').addEventListener('click', () => {
            dialog.remove();
        });
        
        setTimeout(() => {
            const clickHandler = (e) => {
                if (!dialog.contains(e.target) && e.target.id !== 'connectionIndicator') {
                    dialog.remove();
                    document.removeEventListener('click', clickHandler);
                }
            };
            document.addEventListener('click', clickHandler);
        }, 100);
    }

    function startConnectionMonitoring() {
        if (connectionCheckInterval) {
            clearInterval(connectionCheckInterval);
        }
        
        connectionCheckInterval = setInterval(async () => {
            if (!document.hidden && USE_BACKEND) {
                await checkAndRestoreBackendConnection(false);
            }
        }, CONNECTION_CHECK_INTERVAL);
        
        console.log(' Started connection monitoring');
    }

    // VOICE RECOGNITION FUNCTIONS
    function initVoiceRecognition() {
        if (!isVoiceRecognitionSupported) {
            console.log(' Voice recognition not supported in this browser');
            if (micBtn) {
                micBtn.style.display = 'none';
            }
            if (voiceFeedback) {
                voiceFeedback.style.display = 'none';
            }
            return;
        }
        
        try {
            recognition = new SpeechRecognition();
            
            if (isMobileDevice) {
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.maxAlternatives = 3;
            } else {
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.maxAlternatives = 1;
            }
            
            recognition.lang = 'en-US';
            
            recognition.onstart = () => {
                console.log(' Voice recognition started');
                isListening = true;
                recognitionActive = true;
                if (micBtn) micBtn.classList.add('active');
                if (voiceFeedback) voiceFeedback.style.display = 'flex';
                if (voiceText) voiceText.textContent = 'Listening... Speak now';
                finalTranscript = '';
                interimTranscript = '';
                
                if (messageInput) {
                    messageInput.value = '';
                    messageInput.focus();
                }
                
                clearTimeout(silenceTimer);
                
                const silenceTimeout = isMobileDevice ? 3000 : 2000;
                silenceTimer = setTimeout(() => {
                    if (isListening && finalTranscript.trim()) {
                        console.log(' Auto-sending after silence');
                        stopVoiceRecognition();
                        setTimeout(() => {
                            if (messageInput && messageInput.value.trim()) {
                                sendMessage();
                            }
                        }, 500);
                    }
                }, silenceTimeout);
            };
            
            recognition.onresult = (event) => {
                clearTimeout(silenceTimer);
                
                interimTranscript = '';
                
                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript + ' ';
                    } else {
                        interimTranscript += transcript;
                    }
                }
                
                const displayText = finalTranscript + interimTranscript;
                if (messageInput) {
                    messageInput.value = displayText;
                    autoResizeTextarea();
                }
                
                if (voiceText) {
                    if (interimTranscript) {
                        voiceText.textContent = `"${interimTranscript}"`;
                    } else if (finalTranscript) {
                        voiceText.textContent = `"${finalTranscript.trim()}"`;
                    }
                }
                
                const silenceTimeout = isMobileDevice ? 3000 : 2000;
                silenceTimer = setTimeout(() => {
                    if (isListening && finalTranscript.trim()) {
                        console.log(' Auto-sending after silence');
                        stopVoiceRecognition();
                        setTimeout(() => {
                            if (messageInput && messageInput.value.trim()) {
                                sendMessage();
                            }
                        }, 500);
                    }
                }, silenceTimeout);
            };
            
            recognition.onerror = (event) => {
                console.error(' Speech recognition error:', event.error);
                
                let errorMessage = 'Voice recognition error';
                switch (event.error) {
                    case 'not-allowed':
                        errorMessage = 'Microphone access denied. Please enable microphone permissions in browser settings.';
                        break;
                    case 'no-speech':
                        errorMessage = 'No speech detected. Please try again.';
                        break;
                    case 'audio-capture':
                        errorMessage = 'No microphone found. Please check your microphone.';
                        break;
                    case 'network':
                        errorMessage = 'Network error occurred. Please check your connection.';
                        break;
                }
                
                showToast(errorMessage, 'error');
                stopVoiceRecognition();
            };
            
            recognition.onend = () => {
                console.log(' Voice recognition ended');
                recognitionActive = false;
                
                if (isListening) {
                    try {
                        setTimeout(() => {
                            if (isListening && recognition) {
                                recognition.start();
                            }
                        }, 100);
                    } catch (e) {
                        console.error('Failed to restart recognition:', e);
                        stopVoiceRecognition();
                    }
                }
            };
            
            console.log(' Voice recognition initialized successfully');
            
        } catch (error) {
            console.error(' Error initializing voice recognition:', error);
            isVoiceRecognitionSupported = false;
            
            if (micBtn) {
                micBtn.style.display = 'none';
            }
            
            if (voiceFeedback) {
                voiceFeedback.style.display = 'none';
            }
            
            showToast('Voice recognition not available in this browser. Try Chrome, Edge, or Safari.', 'warning');
        }
    }

    function toggleVoiceRecognition() {
        if (!isVoiceRecognitionSupported) {
            showToast('Voice recognition not supported in your browser. Try Chrome, Edge, or Safari.', 'error');
            return;
        }
        
        if (isListening) {
            stopVoiceRecognition();
        } else {
            startVoiceRecognition();
        }
    }

    function startVoiceRecognition() {
        if (!isVoiceRecognitionSupported || !recognition) {
            showToast('Voice recognition not supported in your browser', 'error');
            return;
        }
        
        if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
            showToast('Voice recognition requires HTTPS on most browsers. Please use HTTPS or localhost.', 'warning');
            return;
        }
        
        if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(() => {
                    try {
                        recognition.start();
                        showToast(' Voice recognition started. Speak now!', 'success');
                    } catch (e) {
                        console.error('Failed to start recognition:', e);
                        showToast('Failed to start voice recognition. Please refresh and try again.', 'error');
                    }
                })
                .catch(err => {
                    console.error('Microphone permission denied:', err);
                    showToast('Microphone access denied. Please allow microphone access in browser settings.', 'error');
                });
        } else {
            try {
                recognition.start();
                showToast(' Voice recognition started. Speak now!', 'success');
            } catch (e) {
                console.error('Failed to start recognition:', e);
                showToast('Failed to start voice recognition', 'error');
            }
        }
    }

    function stopVoiceRecognition() {
        isListening = false;
        recognitionActive = false;
        clearTimeout(silenceTimer);
        
        if (recognition) {
            try {
                recognition.stop();
            } catch (e) {
                console.error('Error stopping recognition:', e);
            }
        }
        
        if (micBtn) micBtn.classList.remove('active');
        if (voiceFeedback) voiceFeedback.style.display = 'none';
        
        if (finalTranscript.trim() && messageInput && messageInput.value.trim()) {
            showToast('Voice message ready. Press Enter or click Send.', 'success');
        }
    }

    // Get current user
    function getCurrentUser() {
        try {
            const loggedInUser = localStorage.getItem('currentUser');
            if (loggedInUser) {
                if (loggedInUser.includes('{') && loggedInUser.includes('}')) {
                    try {
                        const userObj = JSON.parse(loggedInUser);
                        return userObj.username || userObj.firstName || (userObj.email ? userObj.email.split('@')[0] : 'User');
                    } catch (e) {
                        console.error('Error parsing user JSON:', e);
                        const usernameMatch = loggedInUser.match(/"username":"([^"]+)"/);
                        const firstNameMatch = loggedInUser.match(/"firstName":"([^"]+)"/);
                        if (usernameMatch && usernameMatch[1]) {
                            return usernameMatch[1];
                        } else if (firstNameMatch && firstNameMatch[1]) {
                            return firstNameMatch[1];
                        }
                        return loggedInUser;
                    }
                }
                return loggedInUser;
            }
            
            const users = JSON.parse(localStorage.getItem('users') || '{}');
            for (const username in users) {
                if (users[username] && users[username].isLoggedIn === true) {
                    localStorage.setItem('currentUser', username);
                    return username;
                }
            }
        } catch (e) {
            console.error('Error reading users:', e);
        }
        
        return 'Guest';
    }

    // Get user display name for welcome message
    function getUserDisplayName() {
        const currentUser = getCurrentUser();
        if (currentUser === 'Guest') return 'there';
        
        try {
            if (currentUser && currentUser.includes('{') && currentUser.includes('}')) {
                try {
                    const userObj = JSON.parse(currentUser);
                    if (userObj.firstName) {
                        return userObj.firstName;
                    } else if (userObj.username) {
                        return userObj.username;
                    }
                } catch (e) {
                    const firstNameMatch = currentUser.match(/"firstName":"([^"]+)"/);
                    const usernameMatch = currentUser.match(/"username":"([^"]+)"/);
                    
                    if (firstNameMatch && firstNameMatch[1]) {
                        return firstNameMatch[1];
                    } else if (usernameMatch && usernameMatch[1]) {
                        return usernameMatch[1];
                    }
                }
            }
            
            const userProfile = localStorage.getItem('userProfile');
            if (userProfile) {
                try {
                    const profile = JSON.parse(userProfile);
                    if (profile.firstName) {
                        return profile.firstName;
                    } else if (profile.username) {
                        return profile.username;
                    }
                } catch (e) {}
            }
        } catch (e) {
            console.error('Error extracting display name:', e);
        }
        
        return currentUser;
    }

    function loadSettings() {
        const savedWebSearch = localStorage.getItem('webSearchEnabled');
        webSearchEnabled = savedWebSearch !== 'false' && ENABLE_WEBSEARCH;
        
        const savedBackground = localStorage.getItem('backgroundProcessingEnabled');
        backgroundProcessing = savedBackground !== 'false';
    }

    // Setup event listeners
    function setupEventListeners() {
        console.log(' Setting up event listeners...');
        
        // Menu toggle
        if (menuToggle) menuToggle.addEventListener('click', () => {
            if (sidebar) sidebar.classList.add('active');
            if (sidebarOverlay) sidebarOverlay.classList.add('active');
        });
        
        // Close sidebar when clicking overlay
        if (sidebarOverlay) sidebarOverlay.addEventListener('click', () => {
            if (sidebar) sidebar.classList.remove('active');
            sidebarOverlay.classList.remove('active');
        });
        
        // Close sidebar on mobile when clicking nav items
        document.querySelectorAll('.nav-item').forEach(item => {
            item.addEventListener('click', () => {
                if (window.innerWidth < 769 && sidebar) {
                    sidebar.classList.remove('active');
                    if (sidebarOverlay) sidebarOverlay.classList.remove('active');
                }
            });
        });

        // New chat
        if (newChatBtn) newChatBtn.addEventListener('click', createNewChat);

        // Send message
        if (sendBtn) sendBtn.addEventListener('click', handleSendButton);
        if (messageInput) messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        // Auto-resize textarea
        if (messageInput) {
            messageInput.addEventListener('input', onMessageInputChange);
        }

        // Attachments
        if (attachBtn) attachBtn.addEventListener('click', toggleAttachmentMenu);
        
        // Close attachment menu when clicking outside
        document.addEventListener('click', (e) => {
            if (attachBtn && attachmentMenu && !attachBtn.contains(e.target) && !attachmentMenu.contains(e.target)) {
                attachmentMenu.classList.remove('show');
            }
        });

        // Attachment options
        document.querySelectorAll('.attachment-option').forEach(btn => {
            btn.addEventListener('click', handleAttachmentOption);
        });

        // Modal close buttons
        document.querySelectorAll('.modal-close, .camera-btn[data-modal]').forEach(btn => {
            btn.addEventListener('click', closeModal);
        });

        // Click outside modal to close
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('active');
                    stopCamera();
                }
            });
        });

        // Camera controls
        document.getElementById('switchCamera')?.addEventListener('click', switchCamera);
        document.getElementById('capturePhoto')?.addEventListener('click', capturePhoto);
        document.getElementById('usePhoto')?.addEventListener('click', usePhoto);
        document.getElementById('uploadFile')?.addEventListener('click', uploadFile);

        // File inputs
        document.getElementById('photoInput')?.addEventListener('change', handlePhotoSelect);
        document.getElementById('fileInput')?.addEventListener('change', handleFileSelect);
        
        // Microphone button
        if (micBtn && isVoiceRecognitionSupported) {
            micBtn.addEventListener('click', toggleVoiceRecognition);
            
            micBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                micBtn.style.transform = 'scale(0.95)';
            }, { passive: false });
            
            micBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                micBtn.style.transform = 'scale(1)';
                toggleVoiceRecognition();
            }, { passive: false });
        } else if (micBtn) {
            micBtn.style.display = 'none';
        }
        
        // Auto-focus message input
        if (messageInput) messageInput.focus();
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', handleVisibilityChange);
        
        // Auto-reconnect when page becomes visible
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && USE_BACKEND) {
                setTimeout(() => checkAndRestoreBackendConnection(true), 1000);
            }
        });
    }

    function handleVisibilityChange() {
        if (document.hidden) {
            offlineMode = true;
            
            if (isListening) {
                clearTimeout(silenceTimer);
            }
            
        } else {
            offlineMode = false;
            updateLastActivityTime();
            
            if (USE_BACKEND) {
                setTimeout(async () => {
                    await checkAndRestoreBackendConnection(false);
                }, 500);
            }
            
            if (isTyping && typingPaused) {
                typingPaused = false;
                sendButtonMode = 'pause';
                updateSendButton();
                if (currentTypingMessage) {
                    continueTyping(currentTypingMessage);
                }
            }
        }
    }

    function onMessageInputChange() {
        autoResizeTextarea();
        
        if (isTyping && typingPaused) {
            sendButtonMode = 'resume';
            updateSendButton();
        } else if (!isTyping) {
            sendButtonMode = 'send';
            updateSendButton();
        }
    }

    function autoResizeTextarea() {
        if (!messageInput) return;
        messageInput.style.height = 'auto';
        messageInput.style.height = Math.min(messageInput.scrollHeight, 200) + 'px';
    }

    function updateLastActivityTime() {
        lastActivityTime = Date.now();
    }

    function toggleAttachmentMenu(e) {
        e.stopPropagation();
        e.preventDefault();
        if (attachmentMenu) attachmentMenu.classList.toggle('show');
    }

    function handleAttachmentOption(e) {
        const type = e.target.closest('.attachment-option').dataset.type;
        openAttachmentModal(type);
        if (attachmentMenu) attachmentMenu.classList.remove('show');
    }

    function closeModal(e) {
        const modalId = e.target.closest('.modal-close')?.dataset.modal || 
                       e.target.closest('.camera-btn[data-modal]')?.dataset.modal;
        if (modalId) {
            const modal = document.getElementById(modalId + 'Modal');
            if (modal) {
                modal.classList.remove('active');
                stopCamera();
            }
        }
    }

    function stopCamera() {
        if (cameraStream) {
            cameraStream.getTracks().forEach(track => track.stop());
            cameraStream = null;
        }
    }

    // SCROLL TRACKING FUNCTIONS
    function setupScrollTracking() {
        scrollToBottomBtn = document.createElement('button');
        scrollToBottomBtn.id = 'scrollToBottomBtn';
        scrollToBottomBtn.innerHTML = '<i class="fas fa-arrow-down"></i>';
        scrollToBottomBtn.title = 'Scroll to bottom';
        scrollToBottomBtn.style.cssText = `
            position: fixed;
            bottom: 100px;
            right: 30px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #8a2be2, #00ffff);
            color: white;
            border: none;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.3s;
            opacity: 0;
            transform: translateY(10px);
        `;
        
        scrollToBottomBtn.addEventListener('click', () => {
            scrollToBottom(true);
            hideScrollButton();
        });
        
        document.body.appendChild(scrollToBottomBtn);
        
        if (chatMessages) {
            chatMessages.addEventListener('scroll', () => {
                const isNearBottom = isUserNearBottom();
                
                if (!isNearBottom) {
                    userScrolledUp = true;
                    showScrollButton();
                } else {
                    userScrolledUp = false;
                    hideScrollButton();
                }
            });
        }
    }

    function isUserNearBottom() {
        if (!chatMessages) return true;
        const threshold = 100;
        const distanceFromBottom = chatMessages.scrollHeight - chatMessages.scrollTop - chatMessages.clientHeight;
        return distanceFromBottom <= threshold;
    }

    function showScrollButton() {
        if (!scrollToBottomBtn) return;
        scrollToBottomBtn.style.display = 'flex';
        setTimeout(() => {
            scrollToBottomBtn.style.opacity = '1';
            scrollToBottomBtn.style.transform = 'translateY(0)';
        }, 10);
    }

    function hideScrollButton() {
        if (!scrollToBottomBtn) return;
        scrollToBottomBtn.style.opacity = '0';
        scrollToBottomBtn.style.transform = 'translateY(10px)';
        setTimeout(() => {
            scrollToBottomBtn.style.display = 'none';
        }, 300);
    }

    function scrollToBottom(force = false) {
        if (!chatMessages) return;
        if (force || !userScrolledUp || isUserNearBottom()) {
            setTimeout(() => {
                chatMessages.scrollTo({
                    top: chatMessages.scrollHeight,
                    behavior: 'smooth'
                });
            }, 100);
        }
    }

    // CHAT MANAGEMENT FUNCTIONS
    function loadChats() {
        const currentUser = getCurrentUser();
        if (!chatList) return;
        
        if (currentUser === 'Guest') {
            chatList.innerHTML = '<div style="text-align: center; padding: 20px; color: #6b7299;">Please log in to see your chats</div>';
            return;
        }
        
        const userChatsKey = `studentAI_chats_${currentUser}`;
        
        try {
            chats = JSON.parse(localStorage.getItem(userChatsKey) || '[]');
        } catch (e) {
            chats = [];
        }
        
        chatList.innerHTML = '';
        
        if (chats.length === 0) {
            chatList.innerHTML = '<div style="text-align: center; padding: 20px; color: #6b7299;">No chats yet</div>';
            return;
        }
        
        chats.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
        
        chats.forEach(chat => {
            const div = document.createElement('div');
            div.className = 'chat-item';
            const timestamp = new Date(chat.timestamp);
            const now = new Date();
            const isToday = timestamp.toDateString() === now.toDateString();
            const timeDisplay = isToday ? 
                `Today ${timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}` :
                timestamp.toLocaleDateString() + ' ' + timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
            
            div.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 4px; padding-right: 40px;">${escapeHtml(chat.title)}</div>
                <div style="font-size: 0.8rem; color: #6b7299;">
                    ${timeDisplay}
                </div>
                <button class="delete-btn" data-id="${chat.id}" title="Delete chat">
                    <i class="fas fa-trash"></i>
                </button>
            `;
            
            div.addEventListener('click', (e) => {
                if (!e.target.closest('.delete-btn')) {
                    loadChat(chat.id);
                }
            });
            
            div.querySelector('.delete-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                deleteChat(chat.id);
            });
            
            chatList.appendChild(div);
        });
    }

    async function createNewChat() {
        const currentUser = getCurrentUser();
        if (currentUser === 'Guest') {
            showToast('Please log in to create a chat');
            return;
        }
        
        if (currentMessages.length > 0) {
            saveCurrentChat();
        }
        
        currentChatId = `chat_${Date.now()}_${currentUser}`;
        const currentChatKey = `currentChat_${currentUser}`;
        localStorage.setItem(currentChatKey, currentChatId);
        currentMessages = [];
        
        const now = new Date();
        const timeStr = now.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        const defaultName = `Chat ${timeStr}`;
        if (currentChatTitle) currentChatTitle.textContent = defaultName;
        
        if (chatMessages) chatMessages.innerHTML = '';
        await showWelcomeMessage();
        
        if (window.innerWidth < 769 && sidebar) {
            sidebar.classList.remove('active');
            if (sidebarOverlay) sidebarOverlay.classList.remove('active');
        }
        
        const chat = {
            id: currentChatId,
            title: defaultName,
            timestamp: new Date().toISOString(),
            messageCount: currentMessages.length,
            userId: currentUser
        };
        
        const userChatsKey = `studentAI_chats_${currentUser}`;
        let userChats = [];
        try {
            userChats = JSON.parse(localStorage.getItem(userChatsKey) || '[]');
        } catch (e) {
            userChats = [];
        }
        
        userChats = userChats.filter(c => c.id !== currentChatId);
        userChats.unshift(chat);
        userChats = userChats.slice(0, 20);
        
        localStorage.setItem(userChatsKey, JSON.stringify(userChats));
        
        showToast('New chat created');
        loadChats();
    }

    function saveCurrentChat() {
        const currentUser = getCurrentUser();
        if (currentUser === 'Guest' || currentMessages.length === 0) return;
        
        let title = currentChatTitle ? currentChatTitle.textContent : 'New Chat';
        
        if (title === 'New Chat' || title === 'Loading...' || title.startsWith('Chat ')) {
            title = generateChatTitle();
            if (currentChatTitle) currentChatTitle.textContent = title;
        }
        
        const chat = {
            id: currentChatId,
            title: title,
            timestamp: new Date().toISOString(),
            messageCount: currentMessages.length,
            userId: currentUser
        };
        
        const userChatsKey = `studentAI_chats_${currentUser}`;
        let userChats = [];
        try {
            userChats = JSON.parse(localStorage.getItem(userChatsKey) || '[]');
        } catch (e) {
            userChats = [];
        }
        
        userChats = userChats.filter(c => c.id !== currentChatId);
        userChats.unshift(chat);
        userChats = userChats.slice(0, 20);
        
        localStorage.setItem(userChatsKey, JSON.stringify(userChats));
        
        const chatMessagesKey = `chat_${currentUser}_${currentChatId}`;
        localStorage.setItem(chatMessagesKey, JSON.stringify(currentMessages));
        
        loadChats();
    }

    function generateChatTitle() {
        const userMessages = currentMessages.filter(m => m.role === 'user');
        
        if (userMessages.length === 0) {
            return 'Study Session';
        }
        
        const firstMessage = userMessages[0].content;
        
        const topics = {
            'math': ['calculate', 'equation', 'algebra', 'calculus', 'geometry', 'math', 'statistics'],
            'science': ['science', 'physics', 'chemistry', 'biology', 'experiment', 'theory'],
            'programming': ['code', 'programming', 'javascript', 'python', 'html', 'css', 'function', 'algorithm'],
            'history': ['history', 'historical', 'war', 'event', 'century'],
            'language': ['translate', 'language', 'grammar', 'vocabulary', 'english', 'spanish'],
            'homework': ['homework', 'assignment', 'project', 'due', 'essay', 'paper'],
            'study': ['study', 'learn', 'review', 'prepare', 'exam', 'test', 'quiz'],
            'notes': ['note', 'notes', 'summary', 'review notes', 'study notes', 'lecture notes'],
            'document': ['document', 'pdf', 'doc', 'docx', 'file', 'image', 'photo', 'scan', 'screenshot']
        };
        
        const lowerMessage = firstMessage.toLowerCase();
        
        for (const [topic, keywords] of Object.entries(topics)) {
            if (keywords.some(keyword => lowerMessage.includes(keyword))) {
                return `Study: ${topic.charAt(0).toUpperCase() + topic.slice(1)}`;
            }
        }
        
        const words = firstMessage.split(' ').slice(0, 5).join(' ');
        return words.length > 30 ? words.substring(0, 30) + '...' : words;
    }

    async function loadChat(chatId) {
        const currentUser = getCurrentUser();
        if (currentUser === 'Guest') {
            showToast('Please log in to load chats');
            return;
        }
        
        currentChatId = chatId;
        const currentChatKey = `currentChat_${currentUser}`;
        localStorage.setItem(currentChatKey, chatId);
        
        const chatMessagesKey = `chat_${currentUser}_${chatId}`;
        try {
            currentMessages = JSON.parse(localStorage.getItem(chatMessagesKey) || '[]');
        } catch (e) {
            currentMessages = [];
        }
        
        const userChatsKey = `studentAI_chats_${currentUser}`;
        const userChats = JSON.parse(localStorage.getItem(userChatsKey) || '[]');
        const chat = userChats.find(c => c.id === chatId);
        if (currentChatTitle) currentChatTitle.textContent = chat ? chat.title : 'Chat';
        
        if (chatMessages) {
            chatMessages.innerHTML = '';
            currentMessages.forEach((msg, index) => {
                renderMessage(msg, index);
            });
        }
        
        if (window.innerWidth < 769 && sidebar) {
            sidebar.classList.remove('active');
            if (sidebarOverlay) sidebarOverlay.classList.remove('active');
        }
        
        showToast('Chat loaded');
        scrollToBottom();
    }

    function deleteChat(chatId) {
        const currentUser = getCurrentUser();
        if (currentUser === 'Guest') {
            showToast('Please log in to delete chats');
            return;
        }
        
        if (!confirm('Delete this chat? This cannot be undone.')) return;
        
        const userChatsKey = `studentAI_chats_${currentUser}`;
        let userChats = [];
        try {
            userChats = JSON.parse(localStorage.getItem(userChatsKey) || '[]');
        } catch (e) {
            userChats = [];
        }
        
        userChats = userChats.filter(chat => chat.id !== chatId);
        localStorage.setItem(userChatsKey, JSON.stringify(userChats));
        
        const chatMessagesKey = `chat_${currentUser}_${chatId}`;
        localStorage.removeItem(chatMessagesKey);
        
        if (chatId === currentChatId) {
            createNewChat();
        }
        
        loadChats();
        showToast('Chat deleted');
    }

    // MESSAGE HANDLING
    async function sendMessage() {
        const currentUser = getCurrentUser();
        if (currentUser === 'Guest') {
            showToast('Please log in to send messages');
            return;
        }
        
        if (isProcessingMessage) {
            showToast('Already processing a message. Please wait.');
            return;
        }
        
        const message = messageInput ? messageInput.value.trim() : '';
        if (!message && pendingAttachments.length === 0) {
            showToast('Please enter a message or add an attachment');
            return;
        }
        
        // Check connection before sending
        if (USE_BACKEND && backendConnectionStatus !== 'connected') {
            const connected = await checkAndRestoreBackendConnection(true);
            if (!connected) {
                showToast('Cannot send message. Backend is not connected.', 'error');
                return;
            }
        }
        
        if (messageInput) {
            messageInput.value = '';
            messageInput.style.height = 'auto';
            messageInput.blur();
        }
        
        const processedAttachments = await Promise.all(pendingAttachments.map(async (attachment) => {
            if (attachment.type === 'photo' && attachment.preview && !attachment.file) {
                try {
                    const blob = base64ToBlob(attachment.preview, attachment.mimeType || 'image/jpeg');
                    if (blob) {
                        const file = new File([blob], attachment.name || `photo_${Date.now()}.jpg`, { 
                            type: attachment.mimeType || 'image/jpeg' 
                        });
                        return {
                            ...attachment,
                            file: file,
                            data: attachment.preview
                        };
                    }
                } catch (e) {
                    console.error('Error converting photo to file:', e);
                }
            }
            return attachment;
        }));
        
        const userMessage = {
            role: 'user',
            content: message,
            attachments: processedAttachments,
            timestamp: new Date().toISOString(),
            editable: true,
            failed: false,
            userId: currentUser
        };
        
        currentMessages.push(userMessage);
        const messageIndex = currentMessages.length - 1;
        
        renderMessage(userMessage, messageIndex);
        
        pendingAttachments = [];
        hideAttachmentPreview();
        
        showThinking();
        
        const hasMultipleFiles = userMessage.attachments.filter(a => 
            a.type === 'file' || a.type === 'photo').length > 1;
        
        if (hasMultipleFiles && !awaitingFileDecision) {
            showFileSeparationDialog(messageIndex);
            awaitingFileDecision = true;
        } else {
            await processMessage(message, userMessage.attachments, messageIndex);
        }
        
        if (currentChatTitle) {
            const currentTitle = currentChatTitle.textContent;
            if (currentTitle === 'New Chat' || currentTitle === 'Loading...' || currentTitle.startsWith('Chat ')) {
                currentChatTitle.textContent = generateChatTitle();
            }
        }
        
        saveCurrentChat();
    }

    function showFileSeparationDialog(messageIndex) {
        hideThinking();
        
        const dialogHTML = `
            <div class="file-dialog">
                <div class="file-dialog-title">
                    <i class="fas fa-code"></i>
                    How should I handle these files?
                </div>
                <p style="margin-bottom: 16px; color: #a0a8d6;">I noticed you have multiple files. Would you like me to:</p>
                <div class="file-dialog-options">
                    <button class="file-option-btn" data-action="separate">
                        <i class="fas fa-file-code"></i>
                        Create separate files
                    </button>
                    <button class="file-option-btn" data-action="join">
                        <i class="fas fa-file-alt"></i>
                        Combine into one file
                    </button>
                </div>
            </div>
        `;
        
        const dialogMessage = {
            role: 'ai',
            content: dialogHTML,
            timestamp: new Date().toISOString(),
            isDialog: true
        };
        
        currentMessages.push(dialogMessage);
        renderMessage(dialogMessage, currentMessages.length - 1);
        
        setTimeout(() => {
            document.querySelectorAll('.file-option-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const action = e.target.closest('.file-option-btn').dataset.action;
                    handleFileDecision(action, messageIndex);
                });
            });
        }, 100);
    }

    function handleFileDecision(action, messageIndex) {
        fileProcessingMode = action;
        awaitingFileDecision = false;
        
        const dialog = document.querySelector('.file-dialog');
        if (dialog) {
            dialog.parentElement.remove();
        }
        
        showThinking();
        const originalMessage = currentMessages[messageIndex];
        processMessage(originalMessage.content, originalMessage.attachments, messageIndex);
    }

    async function processMessage(message, attachments, messageIndex) {
        if (isProcessingMessage) return;
        
        isProcessingMessage = true;
        
        try {
            // Analyze files first
            const filesToAnalyze = attachments.filter(att => 
                (att.type === 'photo' || att.type === 'file') && 
                !att.analyzed && 
                !att.analysisInProgress
            );
            
            if (filesToAnalyze.length > 0) {
                await analyzeFiles(filesToAnalyze, messageIndex);
                
                const updatedAttachments = attachments.map(att => {
                    const analyzedFile = analyzedFiles.get(att.id || att.name);
                    if (analyzedFile) {
                        return {
                            ...att,
                            analyzed: true,
                            analysis: analyzedFile.analysis,
                            analysisText: analyzedFile.text || '',
                            mimeType: analyzedFile.mimeType
                        };
                    }
                    return att;
                });
                
                attachments = updatedAttachments;
            }
            
            const aiResponse = await getAIResponse(message, attachments);
            hideThinking();
            
            const currentUser = getCurrentUser();
            const currentChatKey = `currentChat_${currentUser}`;
            const currentChatIdForUser = localStorage.getItem(currentChatKey);
            
            if (currentChatId === currentChatIdForUser) {
                await typeAIResponse(aiResponse);
                saveCurrentChat();
            }
            
        } catch (error) {
            console.error('Error in processMessage:', error);
            hideThinking();
            
            if (currentMessages[messageIndex]) {
                currentMessages[messageIndex].failed = true;
            }
            
            updateMessageWithRetry(messageIndex);
            saveCurrentChat();
            
            showToast('Failed to send. Click the red retry button.', 'error');
        } finally {
            isProcessingMessage = false;
        }
    }

    // FILE ANALYSIS FUNCTIONS
    async function analyzeFiles(files, messageIndex) {
        console.log(` Analyzing ${files.length} file(s)...`);
        
        if (files.length === 0) return;
        
        showFileAnalysisIndicator(files, messageIndex);
        
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            try {
                console.log(` Analyzing file ${i + 1}/${files.length}: ${file.name || file.title}`);
                
                let analysisResult = null;
                
                if (file.type === 'photo') {
                    analysisResult = await analyzeImage(file);
                } else if (file.type === 'file') {
                    analysisResult = await analyzeDocument(file);
                }
                
                if (analysisResult) {
                    const fileId = file.id || file.name || `file_${i}`;
                    analyzedFiles.set(fileId, {
                        ...analysisResult,
                        name: file.name || file.title,
                        type: file.type
                    });
                    
                    console.log(` File ${i + 1} analyzed successfully`);
                    updateFileAnalysisIndicator(fileId, 'complete', analysisResult.analysis?.substring(0, 100) + '...', messageIndex);
                }
            } catch (error) {
                console.error(` Failed to analyze file ${i + 1}:`, error);
                const fileId = file.id || file.name || `file_${i}`;
                updateFileAnalysisIndicator(fileId, 'failed', error.message, messageIndex);
            }
        }
        
        console.log(' File analysis complete');
    }

    async function analyzeImage(file) {
        if (!USE_BACKEND || backendConnectionStatus !== 'connected') {
            return {
                analysis: `Image: ${file.name || 'Untitled Image'}\nTo analyze images in detail, please ensure backend connection is available.`,
                text: `Image file: ${file.name || 'Untitled Image'}`,
                mimeType: file.mimeType || 'image/jpeg'
            };
        }
        
        try {
            console.log(` Sending image for analysis: ${file.name}`);
            
            const formData = new FormData();
            
            let imageBlob = null;
            
            if (file.file) {
                imageBlob = file.file;
            } else if (file.data && file.data.startsWith('data:')) {
                imageBlob = base64ToBlob(file.data, file.mimeType || 'image/jpeg');
            } else if (file.preview && file.preview.startsWith('data:')) {
                imageBlob = base64ToBlob(file.preview, file.mimeType || 'image/jpeg');
            }
            
            if (!imageBlob) {
                throw new Error('No image data available for analysis');
            }
            
            formData.append('image', imageBlob, file.name || 'image.jpg');
            formData.append('prompt', 'Analyze this image in detail. If there is text, read it all carefully. Describe what you see, including colors, objects, text, and any important details.');
            
            if (file.description) {
                formData.append('description', file.description);
            }
            
            const response = await fetch(IMAGE_ANALYSIS_URL, {
                method: 'POST',
                body: formData,
                mode: 'cors',
                credentials: 'omit'
            });
            
            if (!response.ok) {
                throw new Error(`Image analysis failed: ${response.status}`);
            }
            
            const data = await response.json();
            console.log(' Image analysis completed');
            
            return {
                analysis: data.analysis || `Image analyzed: ${file.name}`,
                text: data.analysis,
                mimeType: data.mimeType || 'image/jpeg',
                fileName: data.fileName,
                fileSize: data.fileSize
            };
            
        } catch (error) {
            console.error(' Image analysis error:', error);
            throw error;
        }
    }

    async function analyzeDocument(file) {
        if (!USE_BACKEND || backendConnectionStatus !== 'connected') {
            return {
                analysis: `Document: ${file.name}\nTo analyze documents in detail, please ensure backend connection is available.`,
                text: `Document file: ${file.name}`,
                mimeType: file.mimeType || 'application/octet-stream'
            };
        }
        
        try {
            console.log(` Sending document for analysis: ${file.name}`);
            
            const formData = new FormData();
            
            if (!file.file) {
                throw new Error('No file object available');
            }
            
            formData.append('document', file.file, file.name);
            formData.append('prompt', 'Extract and analyze this document. Provide a comprehensive summary, identify key points, extract all important information for study.');
            
            if (file.description) {
                formData.append('description', file.description);
            }
            
            const response = await fetch(DOCUMENT_ANALYSIS_URL, {
                method: 'POST',
                body: formData,
                mode: 'cors',
                credentials: 'omit'
            });
            
            if (!response.ok) {
                throw new Error(`Document analysis failed: ${response.status}`);
            }
            
            const data = await response.json();
            console.log(' Document analysis completed');
            
            return {
                analysis: data.analysis || `Document analyzed: ${file.name}`,
                text: data.analysis,
                mimeType: data.fileType || file.mimeType || 'application/octet-stream',
                fileName: data.fileName,
                extractedLength: data.extractedLength
            };
            
        } catch (error) {
            console.error(' Document analysis error:', error);
            throw error;
        }
    }

    function showFileAnalysisIndicator(files, messageIndex) {
        const messageDiv = chatMessages?.querySelector(`[data-index="${messageIndex}"]`);
        if (!messageDiv) return;
        
        const indicator = document.createElement('div');
        indicator.className = 'file-analysis-indicator';
        indicator.id = `file-analysis-${messageIndex}`;
        
        let html = `<div style="display: flex; align-items: center; gap: 8px; color: #ff8e53; font-size: 0.9rem;">
            <i class="fas fa-spinner"></i>
            <span>Analyzing ${files.length} file(s)...</span>
        </div>`;
        
        html += `<div style="margin-top: 8px; font-size: 0.8rem; color: #a0a8d6;">`;
        files.forEach((file, index) => {
            const fileId = file.id || file.name || `file_${index}`;
            html += `<div id="file-status-${fileId.replace(/[^a-zA-Z0-9]/g, '-')}" 
                          class="file-analysis-in-progress"
                          style="padding: 4px 8px; margin: 2px 0; border-radius: 4px; display: flex; align-items: center; gap: 8px;">
                <i class="fas fa-file"></i>
                <span style="flex: 1;">${file.name || file.title || 'File ' + (index + 1)}</span>
                <span style="font-size: 0.7rem; color: #ff8e53;">Analyzing...</span>
            </div>`;
        });
        html += `</div>`;
        
        indicator.innerHTML = html;
        messageDiv.appendChild(indicator);
        
        scrollToBottom();
    }

    function updateFileAnalysisIndicator(fileId, status, text = '', messageIndex) {
        const safeFileId = fileId.replace(/[^a-zA-Z0-9]/g, '-');
        const fileStatusElement = document.getElementById(`file-status-${safeFileId}`);
        
        if (!fileStatusElement) return;
        
        fileStatusElement.classList.remove('file-analysis-in-progress', 'file-analysis-complete', 'file-analysis-failed');
        fileStatusElement.classList.add(`file-analysis-${status}`);
        
        const statusSpan = fileStatusElement.querySelector('span:last-child');
        if (statusSpan) {
            let statusText = '';
            let icon = '';
            let color = '';
            
            switch(status) {
                case 'complete':
                    statusText = ' Analyzed';
                    icon = 'fas fa-check';
                    color = '#4caf50';
                    break;
                case 'failed':
                    statusText = ' Failed';
                    icon = 'fas fa-times';
                    color = '#f44336';
                    break;
                default:
                    statusText = 'Analyzing...';
                    icon = 'fas fa-spinner';
                    color = '#ff8e53';
            }
            
            statusSpan.innerHTML = `<i class="${icon}" style="color: ${color};"></i> ${statusText}`;
            statusSpan.style.color = color;
        }
    }

    function isUserActive() {
        return document.visibilityState === 'visible' && 
               !document.hidden &&
               Date.now() - lastActivityTime < 30000;
    }

    // AI RESPONSE FUNCTIONS
    async function getAIResponse(message, attachments = []) {
        console.log(' Getting AI response...');
        
        if (!USE_BACKEND || backendConnectionStatus !== 'connected') {
            console.log(' Backend not connected');
            throw new Error('Network unavailable - please check your connection and retry');
        }
        
        try {
            const currentUser = getCurrentUser();
            
            const systemPrompt = `You are an intelligent AI study assistant for students. Help with homework, study techniques, note organization, exam preparation, and programming. Be thorough, helpful, and always provide the specific analysis the user requested.

    Provide concise, helpful responses. If analyzing files, focus on key points and actionable insights.`;

            let context = '';
            
            if (attachments && attachments.length > 0) {
                console.log(` Processing ${attachments.length} attachment(s) for context`);
                
                const analyzedAttachments = attachments.filter(a => a.analysis);
                const unanalyzedAttachments = attachments.filter(a => !a.analysis);
                
                context = '\n\n**USER HAS PROVIDED THE FOLLOWING FILES/ATTACHMENTS:**\n';
                
                if (analyzedAttachments.length > 0) {
                    context += `\n**ANALYZED FILES (${analyzedAttachments.length}):**\n`;
                    
                    analyzedAttachments.forEach((att, index) => {
                        context += `\nFILE ${index + 1}: ${att.name || 'File'}\n`;
                        context += `Type: ${att.type === 'photo' ? 'Image' : 'Document'}\n`;
                        
                        if (att.analysis) {
                            context += `\nANALYSIS:\n${att.analysis}\n`;
                        }
                    });
                }
            }

            const fullMessage = message + context;
            
            const messages = [];
            messages.push({ role: 'system', content: systemPrompt });
            
            const recentMessages = currentMessages.slice(-10);
            for (const msg of recentMessages) {
                if (msg.role === 'user') {
                    messages.push({ role: 'user', content: msg.content });
                } else if (msg.role === 'ai' && !msg.isDialog) {
                    messages.push({ role: 'assistant', content: msg.content });
                }
            }
            
            messages.push({ role: 'user', content: fullMessage });
            
            console.log(' Sending request to backend...');
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // Reduced timeout
            
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        messages: messages,
                        max_tokens: 1500, // Reduced for faster responses
                        temperature: 0.7,
                        user: currentUser,
                        attachments: attachments,
                        has_files: attachments.length > 0
                    }),
                    signal: controller.signal,
                    mode: 'cors',
                    credentials: 'omit'
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`Backend error (${response.status})`);
                }
                
                const data = await response.json();
                console.log(' AI Response received');
                
                let aiResponse = data.reply || data.message || data.choices?.[0]?.message?.content || 
                               data.content || data.response || data.answer || 
                               "I've processed your request successfully!";
                
                lastSuccessfulConnection = Date.now();
                retryAttempts = 0;
                
                if (typeof aiResponse !== 'string') {
                    aiResponse = JSON.stringify(aiResponse);
                }
                
                return aiResponse;
                
            } catch (fetchError) {
                clearTimeout(timeoutId);
                throw fetchError;
            }
            
        } catch (error) {
            console.error(' Backend API call failed:', error);
            throw new Error('Unable to connect to AI service. Please check your connection and try again.');
        }
    }

    function updateMessageWithRetry(messageIndex) {
        const messageDiv = chatMessages?.querySelector(`[data-index="${messageIndex}"]`);
        if (!messageDiv) return;
        
        messageDiv.classList.add('failed');
        
        const existingRetry = messageDiv.querySelector('.retry-btn-outside');
        if (existingRetry) existingRetry.remove();
        
        const retryBtn = document.createElement('button');
        retryBtn.className = 'retry-btn-outside';
        retryBtn.title = 'Retry sending this message';
        retryBtn.innerHTML = '<i class="fas fa-redo"></i>';
        retryBtn.onclick = (e) => {
            e.stopPropagation();
            retryMessage(messageIndex);
        };
        
        messageDiv.insertBefore(retryBtn, messageDiv.firstChild);
    }

    function updateFailedMessages() {
        if (!chatMessages) return;
        const failedMessages = chatMessages.querySelectorAll('.message.failed');
        failedMessages.forEach(messageDiv => {
            const index = parseInt(messageDiv.dataset.index);
            if (currentMessages[index] && currentMessages[index].failed) {
                const retryBtn = messageDiv.querySelector('.retry-btn-outside');
                if (retryBtn) {
                    retryBtn.style.background = 'linear-gradient(135deg, #00b09b, #96c93d)';
                    retryBtn.title = 'Backend reconnected! Click to retry';
                }
            }
        });
    }

    function retryMessage(messageIndex) {
        console.log(' Retrying message at index:', messageIndex);
        
        const message = currentMessages[messageIndex];
        if (!message) return;
        
        message.failed = false;
        
        const messageDiv = chatMessages?.querySelector(`[data-index="${messageIndex}"]`);
        if (messageDiv) {
            const retryBtn = messageDiv.querySelector('.retry-btn-outside');
            if (retryBtn) retryBtn.remove();
            messageDiv.classList.remove('failed');
        }
        
        let aiMessageIndex = -1;
        for (let i = messageIndex + 1; i < currentMessages.length; i++) {
            if (currentMessages[i].role === 'ai') {
                aiMessageIndex = i;
                break;
            }
        }
        
        if (aiMessageIndex !== -1) {
            currentMessages.splice(aiMessageIndex, 1);
            
            const aiMessageDiv = chatMessages?.querySelector(`[data-index="${aiMessageIndex}"]`);
            if (aiMessageDiv) {
                aiMessageDiv.remove();
            }
            
            updateMessageIndices();
        }
        
        showThinking();
        processMessage(message.content, message.attachments, messageIndex);
    }

    // TYPING FUNCTIONS
    async function typeAIResponse(text) {
        if (isTyping) return;
        
        isTyping = true;
        typingPaused = false;
        sendButtonMode = 'pause';
        updateSendButton();
        
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message ai-message';
        messageDiv.innerHTML = '<div class="ai-content"></div>';
        
        if (chatMessages) chatMessages.appendChild(messageDiv);
        
        const contentDiv = messageDiv.querySelector('.ai-content');
        const formattedText = md.render(text);
        
        scrollToBottom();
        
        // Fast typing for AI responses
        await typeTextFast(contentDiv, formattedText);
        
        processCodeBlocks(messageDiv);
        
        currentMessages.push({
            role: 'ai',
            content: text,
            timestamp: new Date().toISOString()
        });
        
        saveCurrentChat();
        
        isTyping = false;
        currentTypingMessage = null;
        sendButtonMode = 'send';
        updateSendButton();
        
        if (isUserNearBottom()) {
            scrollToBottom();
        }
    }

    // Fast typing for AI responses
    async function typeTextFast(element, html) {
        return new Promise(resolve => {
            element.innerHTML = html;
            processCodeBlocks(element.parentElement);
            resolve();
        });
    }

    function showThinking() {
        if (isThinking) return;
        isThinking = true;
        
        const thinkingDiv = document.createElement('div');
        thinkingDiv.className = 'thinking';
        thinkingDiv.id = 'thinking';
        
        let thinkingText = 'Thinking...';
        if (backendConnectionStatus !== 'connected') {
            thinkingText = 'Processing (offline)...';
        }
        
        const hasFilesToAnalyze = pendingAttachments.some(att => 
            (att.type === 'photo' || att.type === 'file') && !att.analyzed
        );
        
        thinkingDiv.innerHTML = `
            <div class="thinking-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>
            ${webSearchEnabled ? '<span style="margin-left: 8px; color: #ff6b6b;"><i class="fas fa-search"></i> Web</span>' : ''}
            ${hasFilesToAnalyze ? '<span style="margin-left: 8px; color: #ff8e53;"><i class="fas fa-file"></i> Analyzing Files</span>' : ''}
            ${backendConnectionStatus !== 'connected' ? '<span style="margin-left: 8px; color: #888888;"><i class="fas fa-cloud"></i> Offline</span>' : ''}
        `;
        
        if (chatMessages) chatMessages.appendChild(thinkingDiv);
        
        if (isUserNearBottom()) {
            scrollToBottom();
        }
    }

    function hideThinking() {
        isThinking = false;
        const element = document.getElementById('thinking');
        if (element) element.remove();
    }

    // WELCOME MESSAGE FUNCTION
    async function showWelcomeMessage() {
        const displayName = getUserDisplayName();
        const randomIndex = Math.floor(Math.random() * welcomeMessages.length);
        const welcomeText = welcomeMessages[randomIndex].replace('{name}', displayName);
    
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message ai-message';
        messageDiv.innerHTML = '<div class="ai-content"></div>';
        
        if (chatMessages) chatMessages.appendChild(messageDiv);
        
        const contentDiv = messageDiv.querySelector('.ai-content');
        const formattedText = md.render(welcomeText);
        
        await typeTextFast(contentDiv, formattedText);
        
        currentMessages.push({
            role: 'ai',
            content: welcomeText,
            timestamp: new Date().toISOString()
        });
        
        saveCurrentChat();
    }

    // MESSAGE RENDERING
    function renderMessage(msg, index) {
        if (!chatMessages) return;
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${msg.role === 'user' ? 'user-message' : 'ai-message'}${msg.failed ? ' failed' : ''}`;
        messageDiv.dataset.index = index;
        
        const timestamp = new Date(msg.timestamp);
        const now = new Date();
        const isToday = timestamp.toDateString() === now.toDateString();
        const timeDisplay = isToday ? 
            `Today ${timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}` :
            timestamp.toLocaleDateString() + ' ' + timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        
        if (msg.role === 'user') {
            let retryButtonHTML = '';
            if (msg.failed) {
                retryButtonHTML = `
                    <button class="retry-btn-outside" title="Retry sending this message">
                        <i class="fas fa-redo"></i>
                    </button>
                `;
            }
            
            messageDiv.innerHTML = `
                ${retryButtonHTML}
                <div class="message-content">
                    ${msg.content ? `<p>${escapeHtml(msg.content)}</p>` : ''}
                    ${renderAttachments(msg.attachments)}
                    <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-top: 8px; text-align: right;">
                        <i class="far fa-clock"></i> ${timeDisplay}
                    </div>
                </div>
                <div class="message-actions">
                    <button class="message-action-btn copy-message" title="Copy message">
                        <i class="far fa-copy"></i>
                    </button>
                    <button class="message-action-btn edit-message" title="Edit message">
                        <i class="far fa-edit"></i>
                    </button>
                </div>
                <div class="message-editing">
                    <textarea class="edit-textarea" placeholder="Edit your message...">${escapeHtml(msg.content || '')}</textarea>
                    <div class="edit-actions">
                        <button class="edit-btn edit-cancel">Cancel</button>
                        <button class="edit-btn edit-save">Save</button>
                    </div>
                </div>
            `;
            
            const retryBtn = messageDiv.querySelector('.retry-btn-outside');
            if (retryBtn) {
                retryBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    retryMessage(index);
                });
            }
            
            const copyBtn = messageDiv.querySelector('.copy-message');
            const editBtn = messageDiv.querySelector('.edit-message');
            const cancelBtn = messageDiv.querySelector('.edit-cancel');
            const saveBtn = messageDiv.querySelector('.edit-save');
            const textarea = messageDiv.querySelector('.edit-textarea');
            
            if (copyBtn) copyBtn.addEventListener('click', () => copyMessage(msg));
            if (editBtn) editBtn.addEventListener('click', () => startEditing(index, messageDiv));
            if (cancelBtn) cancelBtn.addEventListener('click', () => cancelEditing(messageDiv));
            if (saveBtn) saveBtn.addEventListener('click', () => saveEditedMessage(index, messageDiv, textarea));
            
        } else if (msg.role === 'ai') {
            if (msg.isDialog) {
                messageDiv.innerHTML = msg.content;
            } else {
                messageDiv.innerHTML = `
                    <div class="ai-content">
                        ${md.render(msg.content)}
                        <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-top: 12px;">
                            <i class="far fa-clock"></i> ${timeDisplay}
                            ${backendConnectionStatus !== 'connected' ? ' <i class="fas fa-cloud" style="margin-left: 8px; color: #888888;"></i> Offline' : ''}
                        </div>
                    </div>
                `;
                
                setTimeout(() => {
                    processCodeBlocks(messageDiv);
                }, 100);
            }
        }
        
        chatMessages.appendChild(messageDiv);
        scrollToBottom();
    }

    function renderAttachments(attachments = []) {
        if (!attachments || attachments.length === 0) return '';
        
        let html = '';
        attachments.forEach((att, index) => {
            const fileId = att.id || att.name || `file_${index}`;
            const fileType = getFileTypeIndicator(att.name || att.title || 'File', att.mimeType);
            
            if (att.type === 'photo') {
                html += `
                    <div style="margin-top: 12px; border-left: 3px solid #ff6b6b; padding-left: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                            <i class="fas fa-image" style="color: #ff6b6b;"></i>
                            <strong>${escapeHtml(att.name)}</strong>
                            <span class="file-type-indicator ${fileType.class}">
                                <i class="${fileType.icon}"></i> ${fileType.text}
                            </span>
                            ${att.description ? `<span style="font-size: 0.8rem; color: rgba(255,255,255,0.7);">- ${escapeHtml(att.description)}</span>` : ''}
                        </div>
                        ${att.preview ? `<img src="${att.preview}" style="max-width: 200px; max-height: 200px; border-radius: 8px; margin: 8px 0;">` : ''}
                    </div>
                `;
            } else if (att.type === 'file') {
                html += `
                    <div style="margin-top: 12px; border-left: 3px solid #8a2be2; padding-left: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                            <i class="fas fa-file" style="color: #8a2be2;"></i>
                            <strong>${escapeHtml(att.name)}</strong>
                            <span class="file-type-indicator ${fileType.class}">
                                <i class="${fileType.icon}"></i> ${fileType.text}
                            </span>
                            ${att.description ? `<span style="font-size: 0.8rem; color: rgba(255,255,255,0.7);">- ${escapeHtml(att.description)}</span>` : ''}
                        </div>
                        ${att.file ? `<div style="font-size: 0.8rem; color: #a0a8d6;">Size: ${formatFileSize(att.file.size)}</div>` : ''}
                    </div>
                `;
            } else if (att.type === 'note') {
                const attachmentCount = att.fileAttachments ? att.fileAttachments.length : 0;
                html += `
                    <div style="margin-top: 12px; border-left: 3px solid #00ffff; padding-left: 12px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                            <i class="fas fa-sticky-note" style="color: #00ffff;"></i>
                            <strong>${escapeHtml(att.title)}</strong>
                            ${attachmentCount > 0 ? `<span class="attachment-count">${attachmentCount} file${attachmentCount > 1 ? 's' : ''}</span>` : ''}
                        </div>
                        ${att.description ? `<div style="font-size: 0.8rem; color: rgba(255,255,255,0.7); margin-bottom: 8px;">${escapeHtml(att.description)}</div>` : ''}
                        <div style="background: rgba(0, 255, 255, 0.1); padding: 10px; border-radius: 6px; margin: 8px 0;">
                            <div style="font-size: 0.9rem; color: rgba(255,255,255,0.9); max-height: 120px; overflow-y: auto;">
                                ${escapeHtml(att.content.substring(0, 500))}${att.content.length > 500 ? '...' : ''}
                            </div>
                        </div>
                    </div>
                `;
            }
        });
        return html;
    }

    function processCodeBlocks(container) {
        if (!container || !window.hljs) return;
        
        container.querySelectorAll('pre code').forEach((codeBlock) => {
            if (codeBlock.closest('.code-block-wrapper')) return;
            
            const wrapper = document.createElement('div');
            wrapper.className = 'code-block-wrapper';
            
            const classList = codeBlock.className.split(' ');
            let language = 'text';
            for (const cls of classList) {
                if (cls.startsWith('language-') || cls.startsWith('lang-')) {
                    language = cls.replace('language-', '').replace('lang-', '');
                    break;
                }
            }
            
            const header = document.createElement('div');
            header.className = 'code-header';
            
            const languageSpan = document.createElement('span');
            languageSpan.className = 'code-language';
            languageSpan.innerHTML = `<i class="fas fa-code"></i> ${language.toUpperCase()}`;
            
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '8px';
            
            const copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.innerHTML = '<i class="far fa-copy"></i> Copy';
            copyBtn.title = 'Copy code to clipboard';
            copyBtn.onclick = () => copyCode(codeBlock, copyBtn);
            
            buttonContainer.appendChild(copyBtn);
            
            header.appendChild(languageSpan);
            header.appendChild(buttonContainer);
            
            const pre = codeBlock.parentNode;
            const codeContainer = document.createElement('div');
            codeContainer.className = 'code-block';
            codeContainer.appendChild(pre.cloneNode(true));
            
            wrapper.appendChild(header);
            wrapper.appendChild(codeContainer);
            
            pre.parentNode.replaceChild(wrapper, pre);
            
            hljs.highlightElement(codeContainer.querySelector('code'));
        });
    }

    function copyCode(codeElement, button) {
        const text = codeElement.textContent;
        navigator.clipboard.writeText(text).then(() => {
            const originalHTML = button.innerHTML;
            button.innerHTML = '<i class="fas fa-check"></i> Copied!';
            button.classList.add('copied');
            
            setTimeout(() => {
                button.innerHTML = originalHTML;
                button.classList.remove('copied');
            }, 2000);
            
            showToast('Code copied to clipboard!', 'success');
        }).catch(err => {
            console.error('Failed to copy code:', err);
            showToast('Failed to copy code', 'error');
        });
    }

    function copyMessage(msg) {
        let text = msg.content || '';
        if (msg.attachments) {
            msg.attachments.forEach(att => {
                text += `\n\nAttachment: ${att.name || att.title}`;
                if (att.description) text += `\nDescription: ${att.description}`;
            });
        }
        
        navigator.clipboard.writeText(text).then(() => {
            showToast('Message copied to clipboard', 'success');
        });
    }

    // MESSAGE EDITING
    function startEditing(index, messageDiv) {
        const nextMessage = currentMessages[index + 1];
        if (nextMessage && nextMessage.role === 'ai') {
            if (!confirm('Editing this message will remove the AI response. Continue?')) {
                return;
            }
            currentMessages.splice(index + 1, 1);
            const aiMessageDiv = chatMessages?.querySelector(`[data-index="${index + 1}"]`);
            if (aiMessageDiv) {
                aiMessageDiv.remove();
            }
            updateMessageIndices();
        }
        
        messageDiv.classList.add('editing');
        const textarea = messageDiv.querySelector('.edit-textarea');
        if (textarea) {
            textarea.focus();
            textarea.setSelectionRange(textarea.value.length, textarea.value.length);
        }
    }

    function cancelEditing(messageDiv) {
        messageDiv.classList.remove('editing');
    }

    function saveEditedMessage(index, messageDiv, textarea) {
        const newText = textarea.value.trim();
        if (!newText && (!currentMessages[index].attachments || currentMessages[index].attachments.length === 0)) {
            showToast('Message cannot be empty', 'warning');
            return;
        }
        
        currentMessages[index].content = newText;
        currentMessages[index].timestamp = new Date().toISOString();
        
        const contentDiv = messageDiv.querySelector('.message-content');
        const timestamp = new Date(currentMessages[index].timestamp);
        const now = new Date();
        const isToday = timestamp.toDateString() === now.toDateString();
        const timeDisplay = isToday ? 
            `Today ${timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}` :
            timestamp.toLocaleDateString() + ' ' + timestamp.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        
        contentDiv.innerHTML = `
            ${newText ? `<p>${escapeHtml(newText)}</p>` : ''}
            ${renderAttachments(currentMessages[index].attachments)}
            <div style="font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-top: 8px; text-align: right;">
                <i class="far fa-clock"></i> ${timeDisplay} (edited)
            </div>
        `;
        
        cancelEditing(messageDiv);
        saveCurrentChat();
        showToast('Message updated', 'success');
        
        if (index === currentMessages.length - 1 && messageInput) {
            setTimeout(() => {
                messageInput.value = newText;
                autoResizeTextarea();
                sendMessage();
            }, 100);
        }
    }

    function updateMessageIndices() {
        if (!chatMessages) return;
        const messages = chatMessages.querySelectorAll('.message');
        messages.forEach((div, index) => {
            div.dataset.index = index;
        });
    }

    // BACKGROUND PROCESSING FUNCTIONS
    function setupBackgroundProcessing() {
        const style = document.createElement('style');
        style.textContent = `
            .background-processing-indicator {
                margin-top: 12px;
                padding: 12px;
                background: rgba(138, 43, 226, 0.1);
                border: 1px solid rgba(138, 43, 226, 0.3);
                border-radius: 8px;
                animation: pulse 2s infinite;
            }
            
            @keyframes pulse {
                0% { opacity: 1; }
                50% { opacity: 0.7; }
                100% { opacity: 1; }
            }
        `;
        document.head.appendChild(style);
    }

    // WEB SEARCH FUNCTIONS
    function setupWebSearchButton() {
        const webSearchToggle = document.createElement('button');
        webSearchToggle.id = 'webSearchToggle';
        webSearchToggle.className = 'chat-control-btn';
        webSearchToggle.title = 'Toggle web search';
        webSearchToggle.innerHTML = '<i class="fas fa-globe"></i>';
        
        const chatControls = document.querySelector('.chat-controls');
        if (chatControls) chatControls.insertBefore(webSearchToggle, sendBtn);
        
        webSearchToggle.addEventListener('click', toggleWebSearch);
        updateWebSearchButton();
    }

    function toggleWebSearch() {
        webSearchEnabled = !webSearchEnabled;
        localStorage.setItem('webSearchEnabled', webSearchEnabled);
        updateWebSearchButton();
        
        showToast(webSearchEnabled ? 'Web search enabled' : 'Web search disabled', 'info');
    }

    function updateWebSearchButton() {
        const webSearchToggle = document.getElementById('webSearchToggle');
        if (!webSearchToggle) return;
        
        webSearchToggle.classList.toggle('active', webSearchEnabled);
    }

    // NOTE SENDING FUNCTIONS
    function setupNoteSending() {
        console.log(' Setting up note sending integration...');
        
        checkForNoteFromUrl();
        
        document.addEventListener('notesModalOpened', async () => {
            await loadNotesForSending();
        });
    }

    async function preloadNotes() {
        const currentUser = getCurrentUser();
        if (currentUser === 'Guest') return;
        
        try {
            const notesKey = `studentAI_notes_${currentUser}`;
            availableNotes = JSON.parse(localStorage.getItem(notesKey) || '[]');
            availableNotes.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            console.log(` Preloaded ${availableNotes.length} notes from notes.html`);
        } catch (error) {
            console.error('Error preloading notes:', error);
            availableNotes = [];
        }
    }

    async function loadNotesForSending() {
        console.log(' Loading notes for sending...');
        
        const currentUser = getCurrentUser();
        if (currentUser === 'Guest') {
            showToast('Please log in to send notes', 'warning');
            return [];
        }
        
        try {
            const notesKey = `studentAI_notes_${currentUser}`;
            const notes = JSON.parse(localStorage.getItem(notesKey) || '[]');
            notes.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            const notesWithAttachments = await Promise.all(
                notes.map(async (note) => {
                    try {
                        const noteAttachmentsKey = `note_attachments_${currentUser}_${note.id}`;
                        const attachments = JSON.parse(localStorage.getItem(noteAttachmentsKey) || '[]');
                        
                        const processedAttachments = [];
                        
                        for (const att of attachments) {
                            if (att.type === 'photo' && att.data) {
                                try {
                                    processedAttachments.push({
                                        type: 'photo',
                                        name: att.name || 'Photo',
                                        preview: att.data,
                                        description: att.description || '',
                                        timestamp: att.timestamp || note.timestamp,
                                        data: att.data,
                                        mimeType: att.mimeType || 'image/jpeg',
                                        id: att.id || `photo_${Date.now()}`
                                    });
                                } catch (e) {
                                    console.error('Error processing photo:', e);
                                }
                            } else if (att.type === 'file' && att.data) {
                                processedAttachments.push({
                                    type: 'file',
                                    name: att.name || 'File',
                                    description: att.description || '',
                                    timestamp: att.timestamp || note.timestamp,
                                    data: att.data,
                                    mimeType: att.mimeType || 'application/octet-stream',
                                    id: att.id || `file_${Date.now()}`
                                });
                            }
                        }
                        
                        note.attachments = processedAttachments;
                        
                    } catch (e) {
                        console.error('Error loading note attachments:', e);
                        note.attachments = [];
                    }
                    
                    return note;
                })
            );
            
            console.log(' Loaded notes with attachments:', notesWithAttachments.length);
            
            return notesWithAttachments;
        } catch (e) {
            console.error('Error loading notes:', e);
            showToast('Error loading notes', 'error');
            return [];
        }
    }

    // UPDATE SEND BUTTON
    function updateSendButton() {
        const icon = sendBtn?.querySelector('i');
        if (!icon) return;
        
        if (sendButtonMode === 'send') {
            icon.className = 'fas fa-paper-plane';
            if (sendBtn) sendBtn.title = 'Send message';
            if (sendBtn) sendBtn.disabled = false;
        } else if (sendButtonMode === 'pause') {
            icon.className = 'fas fa-pause';
            if (sendBtn) sendBtn.title = 'Pause AI typing';
            if (sendBtn) sendBtn.disabled = false;
        } else if (sendButtonMode === 'resume') {
            icon.className = 'fas fa-play';
            if (sendBtn) sendBtn.title = 'Resume AI typing';
            if (sendBtn) sendBtn.disabled = false;
        }
    }

    function handleSendButton() {
        if (sendButtonMode === 'send') {
            sendMessage();
        } else if (sendButtonMode === 'pause') {
            typingPaused = true;
            sendButtonMode = 'resume';
            updateSendButton();
        } else if (sendButtonMode === 'resume') {
            typingPaused = false;
            sendButtonMode = 'pause';
            updateSendButton();
            if (currentTypingMessage) {
                continueTyping(currentTypingMessage);
            }
        }
    }

    // RENDER ALL MESSAGES
    function renderMessages() {
        if (!chatMessages) return;
        chatMessages.innerHTML = '';
        currentMessages.forEach((msg, index) => {
            renderMessage(msg, index);
        });
    }

    // ATTACHMENT FUNCTIONS
    function openAttachmentModal(type) {
        if (type === 'camera') {
            document.getElementById('cameraModal')?.classList.add('active');
            startCamera();
        } else if (type === 'photo') {
            document.getElementById('photoModal')?.classList.add('active');
            const previewContainer = document.getElementById('photoPreviewContainer');
            const preview = document.getElementById('photoPreview');
            const description = document.getElementById('photoDescription');
            if (previewContainer) previewContainer.style.display = 'none';
            if (preview) preview.src = '';
            if (description) description.value = '';
        } else if (type === 'file') {
            document.getElementById('fileModal')?.classList.add('active');
            const fileInfo = document.getElementById('fileInfo');
            const fileName = document.getElementById('fileName');
            const fileDescription = document.getElementById('fileDescription');
            if (fileInfo) fileInfo.style.display = 'none';
            if (fileName) fileName.textContent = '';
            if (fileDescription) fileDescription.value = '';
        } else if (type === 'notes') {
            document.getElementById('notesModal')?.classList.add('active');
            const event = new Event('notesModalOpened');
            document.dispatchEvent(event);
        }
    }

    async function startCamera() {
        try {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showToast('Camera not supported on this device', 'error');
                document.getElementById('cameraModal')?.classList.remove('active');
                return;
            }
            
            const constraints = {
                video: { facingMode: facingMode },
                audio: false
            };
            
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
            
            cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
            const video = document.getElementById('cameraVideo');
            if (video) video.srcObject = cameraStream;
        } catch (error) {
            showToast('Cannot access camera. Please check permissions.', 'error');
            document.getElementById('cameraModal')?.classList.remove('active');
        }
    }

    function switchCamera() {
        facingMode = facingMode === 'user' ? 'environment' : 'user';
        startCamera();
    }

    function capturePhoto() {
        const video = document.getElementById('cameraVideo');
        const canvas = document.getElementById('photoCanvas');
        if (!video || !canvas) return;
        
        const context = canvas.getContext('2d');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        context.drawImage(video, 0, 0);
        
        canvas.toBlob(blob => {
            const timestamp = new Date().toISOString();
            const file = new File([blob], `photo_${timestamp.replace(/[:.]/g, '-')}.png`, { type: 'image/png' });
            const reader = new FileReader();
            
            reader.onload = (e) => {
                const base64 = e.target.result;
                pendingAttachments.push({
                    type: 'photo',
                    name: file.name,
                    preview: base64,
                    file: file,
                    data: base64,
                    description: '',
                    timestamp: timestamp,
                    id: `photo_${Date.now()}`,
                    mimeType: file.type
                });
                
                document.getElementById('cameraModal')?.classList.remove('active');
                document.getElementById('photoModal')?.classList.add('active');
                
                const previewContainer = document.getElementById('photoPreviewContainer');
                const photoPreview = document.getElementById('photoPreview');
                const photoDescription = document.getElementById('photoDescription');
                
                if (previewContainer) previewContainer.style.display = 'block';
                if (photoPreview) photoPreview.src = base64;
                if (photoDescription) {
                    photoDescription.value = '';
                    photoDescription.focus();
                }
                
                stopCamera();
                showToast('Photo captured! Add a description.', 'success');
            };
            reader.readAsDataURL(blob);
        }, 'image/png');
    }

    function usePhoto() {
        const description = document.getElementById('photoDescription')?.value.trim() || '';
        if (pendingAttachments.length > 0) {
            const lastAttachment = pendingAttachments[pendingAttachments.length - 1];
            lastAttachment.description = description;
            
            if (messageInput) {
                messageInput.value = description ? description + ' ' : '';
                messageInput.focus();
                autoResizeTextarea();
            }
            
            document.getElementById('photoModal')?.classList.remove('active');
            showToast('Photo attached. Send your message.', 'success');
            showAttachmentPreview();
        }
    }

    function handlePhotoSelect(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        if (file.size > 10 * 1024 * 1024) {
            showToast('File too large. Maximum 10MB.', 'error');
            return;
        }
        
        const reader = new FileReader();
        reader.onload = (e) => {
            const base64 = e.target.result;
            pendingAttachments.push({
                type: 'photo',
                name: file.name,
                preview: base64,
                file: file,
                data: base64,
                description: '',
                timestamp: new Date().toISOString(),
                id: `photo_${Date.now()}`,
                mimeType: file.type
            });
            
            const previewContainer = document.getElementById('photoPreviewContainer');
            const photoPreview = document.getElementById('photoPreview');
            const photoDescription = document.getElementById('photoDescription');
            
            if (previewContainer) previewContainer.style.display = 'block';
            if (photoPreview) photoPreview.src = base64;
            if (photoDescription) {
                photoDescription.value = '';
                photoDescription.focus();
            }
        };
        reader.readAsDataURL(file);
    }

    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        if (file.size > 10 * 1024 * 1024) {
            showToast('File too large. Maximum 10MB.', 'error');
            return;
        }
        
        const supportedTypes = [
            'application/pdf',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'text/plain',
            'image/jpeg',
            'image/png',
            'image/gif',
            'image/webp'
        ];
        
        if (!supportedTypes.includes(file.type) && !file.name.match(/\.(pdf|docx|doc|txt|jpg|jpeg|png|gif|webp)$/i)) {
            showToast('Unsupported file type. Please upload PDF, DOCX, TXT, or image files.', 'error');
            return;
        }
        
        const isImage = file.type.startsWith('image/');
        
        pendingAttachments.push({
            type: isImage ? 'photo' : 'file',
            name: file.name,
            file: file,
            description: '',
            timestamp: new Date().toISOString(),
            id: `${isImage ? 'photo' : 'file'}_${Date.now()}`,
            mimeType: file.type
        });
        
        const fileInfo = document.getElementById('fileInfo');
        const fileName = document.getElementById('fileName');
        const fileDescription = document.getElementById('fileDescription');
        
        if (fileInfo) fileInfo.style.display = 'block';
        if (fileName) fileName.textContent = file.name;
        if (fileDescription) {
            fileDescription.value = '';
            fileDescription.focus();
        }
        
        const fileType = getFileTypeIndicator(file.name, file.type);
        if (fileName) {
            const typeSpan = document.createElement('span');
            typeSpan.className = `file-type-indicator ${fileType.class}`;
            typeSpan.innerHTML = `<i class="${fileType.icon}"></i> ${fileType.text}`;
            typeSpan.style.marginLeft = '8px';
            fileName.appendChild(typeSpan);
        }
    }

    function uploadFile() {
        const description = document.getElementById('fileDescription')?.value.trim() || '';
        if (pendingAttachments.length > 0) {
            const lastAttachment = pendingAttachments[pendingAttachments.length - 1];
            lastAttachment.description = description;
            
            if (messageInput) {
                messageInput.value = description ? description + ' ' : '';
                messageInput.focus();
                autoResizeTextarea();
            }
            
            document.getElementById('fileModal')?.classList.remove('active');
            showToast('File attached. Send your message.', 'success');
            showAttachmentPreview();
        }
    }

    // NAVIGATION
    function navigateTo(page) {
        saveCurrentChat();
        stopConnectionMonitoring();
        window.location.href = page;
    }

    function stopConnectionMonitoring() {
        if (connectionCheckInterval) {
            clearInterval(connectionCheckInterval);
            connectionCheckInterval = null;
        }
    }

    // UTILITY FUNCTIONS
    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function showToast(message, type = 'info', duration = 3000) {
        const toastContainer = document.getElementById('toastContainer') || (() => {
            const container = document.createElement('div');
            container.id = 'toastContainer';
            container.style.cssText = `
                position: fixed;
                bottom: 20px;
                left: 0;
                right: 0;
                display: flex;
                flex-direction: column;
                align-items: center;
                z-index: 9999;
                pointer-events: none;
            `;
            document.body.appendChild(container);
            return container;
        })();
        
        const existingToasts = toastContainer.querySelectorAll('.toast');
        for (const toast of existingToasts) {
            if (toast.textContent.includes(message.substring(0, 50))) {
                return;
            }
        }
        
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        
        toastContainer.appendChild(toast);
        
        setTimeout(() => {
            if (toast.parentNode) {
                toast.remove();
            }
        }, duration);
    }

    function showAttachmentPreview() {
        hideAttachmentPreview();
        
        if (pendingAttachments.length === 0) return;
        
        const preview = document.createElement('div');
        preview.id = 'attachmentPreview';
        
        let previewHTML = '<div style="font-size: 0.9rem; color: #a0a8d6; margin-bottom: 8px;"><i class="fas fa-paperclip"></i> Attached:</div>';
        previewHTML += '<div style="display: flex; flex-wrap: wrap; gap: 8px;">';
        
        pendingAttachments.forEach((att, index) => {
            let icon = 'fa-file';
            let color = '#8a2be2';
            
            if (att.type === 'photo') {
                icon = 'fa-image';
                color = '#ff6b6b';
            } else if (att.type === 'note') {
                icon = 'fa-sticky-note';
                color = '#00ffff';
            }
            
            const fileType = getFileTypeIndicator(att.name || att.title || 'File', att.mimeType);
            
            previewHTML += `
                <div style="
                    background: ${color}20;
                    border: 1px solid ${color}40;
                    border-radius: 6px;
                    padding: 6px 10px;
                    font-size: 0.8rem;
                    display: flex;
                    align-items: center;
                    gap: 6px;
                    position: relative;
                ">
                    <i class="fas ${icon}" style="color: ${color};"></i>
                    <span style="max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                        ${escapeHtml(att.name || att.title || 'Attachment')}
                    </span>
                    <span class="file-type-indicator ${fileType.class}" style="font-size: 0.6rem; padding: 1px 4px;">
                        <i class="${fileType.icon}"></i> ${fileType.text}
                    </span>
                    ${att.type === 'note' && att.fileAttachments && att.fileAttachments.length > 0 ? 
                        `<span class="attachment-count">${att.fileAttachments.length}</span>` : ''}
                    <button onclick="removeAttachment(${index})" style="
                        background: none;
                        border: none;
                        color: #ff6b6b;
                        cursor: pointer;
                        padding: 0;
                        margin-left: 4px;
                    ">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `;
        });
        
        previewHTML += '</div>';
        preview.innerHTML = previewHTML;
        
        const chatControls = document.querySelector('.chat-controls');
        if (chatControls) {
            chatControls.parentNode.insertBefore(preview, chatControls);
        }
    }

    function hideAttachmentPreview() {
        const existingPreview = document.getElementById('attachmentPreview');
        if (existingPreview) {
            existingPreview.remove();
        }
    }

    function removeAttachment(index) {
        if (index >= 0 && index < pendingAttachments.length) {
            pendingAttachments.splice(index, 1);
            showAttachmentPreview();
            
            if (pendingAttachments.length === 0 && messageInput) {
                messageInput.placeholder = 'Type your message here...';
            }
        }
    }

    // MAKE FUNCTIONS AVAILABLE GLOBALLY
    window.navigateTo = navigateTo;
    window.toggleVoiceRecognition = toggleVoiceRecognition;
    window.createNewChat = createNewChat;
    window.removeAttachment = removeAttachment;

    // Initialize when DOM is loaded
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }
</script>
</body>
</html>
